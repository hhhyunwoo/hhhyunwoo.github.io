---
layout: post
title: "[Linux System Programming] Ch05 프로세스 관리 "
date: 2022-03-24
categories:
  - Trouble Shooting
tags:
  [
    blog,
    jekyll,
    jekyll theme,
    NexT theme,
    Computer Science,
    컴퓨터공학,
    개발,
    소프트웨어,
    지킬 테마,
    지킬 블로그 포스팅,
    GitHub Pages,
  ]
---

# [Ch05 프로세스 관리]

- 유닉스는 새로운 바이너리 이미지를 메모리에 적재하는 과정에서 새로운 프로세스를 생성하는 부분을 분리했다.

# 5.1 프로그램, 프로세스, 스레드

- 바이너리는 디스크 같은 저장 장치에 기록되어 있는 컴파일된 실행할 수 있는 코드를 말한다.
  - 흔히 프로그램을 지칭하기도 함.
  - 때로는 애플리케이션을 뜻하기도 함.
  - /bin/ls, /usr/bin/X11 모두 바이너리
- 프로세스는 실행 중인 프로그램을 뜻함.
  - 프로세스는 메모리에 적재된 바이너리 이미지와 가상화된 메모리의 인스턴스, 열린 파일 같은 커널 리소스, 관련된 사용자 정보와 같은 보안 정보와 하나 이상의 스레드를 포함하고 있다.
- 스레드는 프로세스 내 실행 단위.
  - 각각의 스레드는 가상화된 프로세서를 가지고 있음
    - 프로세서에는 스택, 레지스터, 명령어 포인터 같은 프로세서의 상태가 포함되어 있다.
  - 싱글 스레드 프로세스는 프로세스가 곧 스레드가 된다.

# 5.2 프로세스 ID

- 모든 프로세스는 프로세스 ID(pid)라고 하는 유일한 식별자로 구분됨.
- pid는 특정 시점에서 유일한 값임을 보장한다.
  - 커널이 같은 프로세스 식별자롤 다른 프로세스에 다시 할당하지 않으리라 가정한다.
- 동작 중인 다른 프로세스가 없을 때 커널이 실행하는 `idle` 프로세스는 Pid가 `0`이다.
- 부팅이 끝나면 커널이 실행하는 최초 프로세스인 `init` 의 pid는 `1`이다.
- 리눅스 커널이 적절한 init 프로세스를 찾으면서 실행할 프로세스를 결정하는 순서
  1. /sbin/init
  2. /etc/init
  3. /bin/init
  4. /bin/sh
  - 이 순서에서 가장 먼저 찾은 프로세스를 실행함.
  - 네 가지 모두 실패하면 panic 발생
    - 복구할 수 없는 치명적인 내부 에러를 감지

## 5.2.1 프로세스 ID 할당

- 보통 커널의 최대 pid 값은 32768이다.
  - pid값으로 signed 16bit integer를 사용했던 오래된 유닉스 시스템과의 호환성을 위함.
- 커널은 pid를 순서대로 엄격하게 할당한다.
  - /proc/sys/kernel/pid_max 값에 도달해서 처음부터 다시 할당하기 전까진 앞선 pid가 비어있더라도 재사용되지 않는다.

## 5.2.2 프로세스 계층

- Spawn(새로운 프로세스를 생성하는) 프로세서를 부모 프로세스라고 한다.
- 새롭게 생성된 프로세스를 자식 프로세스라고 한다.
- init 프로세스를 제외한 모든 프로세스는 다른 프로세스로부터 생성된다.
  - → 그래서 모든 자식 프로세스에는 부모 프로세스가 있다.
  - ppid 로 확인가능함.
- 모든 프로세스는 사용자와 그룹이 소유하고 있다.
  - 모든 자식 프로세스는 부모 프로세스의 사용자와 그룹 권한을 상속받는다.
  - 접근 권한을 제어하기 위해 사용됨.
- 프로세스 그룹
  - 프로세스와 다른 프로세시의 관계를 표현하고 있음.

## 5.2.3 pid_t

- pid 는 pid_t 자료형으로 표현됨
  - C의 int 자료형에 대한 typedef이다.

## 5.2.4 프로세스 ID와 부모 프로세스 ID 얻기

- getpid() 시스템 콜은 호출한 프로세스의 pid를 반환함.

```c
#include <sys/types.h>
#include <unistd.h>

pid_t getpid (void);
```

- getppid() 는 호출한 프로세스의 부모 프로세스 pid를 반환함

```c
#include <sys/types.h>
#include <unistd.h>

pid_t getppid (void);
```

- 예제
  ```c
  printf ("My pid=%jd\n", (intmax_t) getpid ());
  printf ("Parent's pid=%jd\n", (intmax_t) getppid ());
  ```

# 5.3 새로운 프로세스 실행하기

- 유닉스에서는
  1. 프로그램 이미지를 메모리에 적재하고 실행하는 과정
  2. 새로운 프로세스를 생성하는 과정
  - 두 가지가 분리되어 있음.

## 5.3.1 exec 함수들

- exec 류 시스템 콜은 한 가지로 제공되지 않고 여러 형태로 제공된다.

- 먼저 excel을 알아보자

```c
#include <unistd.h>

int execl (const char *path,
           const char *arg,
           ...);
```

- 호출하면 현재 프로세스를 path가 가리키는 프로그램으로 대체한다.
- `arg`
  - path에 명시된 프로그램을 위한 첫 번째 인자다.
- `...`
  - 가변인자
  - 뒤에 다른 인자가 여럿 올 수 있음
  - 마지막은 반드시 NULL로 끝나야함.
- 예제

  ```c
  int ret;

  ret = execl ("/bin/vi", "vi", NULL);
  if (ret == −1)
          perror ("execl");
  ```

  - 실행 파일의 경로인 path의 마지막 요소 vi 를 첫 번째 인자로 두어, 프로세스의 fork()/exec 과정에서 argv[0]을 검사하여 바이너리 이미지의 이름을 찾을 수 있도록 한다.

- 일반적으로 반환값이 없다.
  - 에러 발생시 -1 반환, errno 설정
  - 성공 시
    - 새로운 프로그램의 시작점으로 건너 뛰므로 이전에 실행했던 코드는 그 프로세스의 주소 공간에 더 이상 존재하지 않음.
    - 대기 중인 시그널 사라짐
    - 프로세스가 받은 시그널은 시그널 핸들러가 더 이상 프로세스의 주소 공간에 존재하지 않으므로 디폴트 방식으로 처리됨
    - 메모리 락이 해제됨
    - 스레드의 속성 대부분이 기본값으로 돌아감
    - 프로세스의 통계 대부분이 재설정됨
    - 맵핑된 파일을 포함하여 프로세스의 메모리 주소 공간과 관련된 모든 내용이 사라짐
    - 사용자 영역에만 존재하는 모든 내용이 사라짐.
- Q) 마지막에 NULL을 넣는 이유는 뭘까?
- 즉, fork 로 childe 프로세스를 만든 후 그 프로세스를 새로운 독립적인 프로세스로 만들어 주는 역할을 한다.

### 다른 exec 함수들

```c
#include <unistd.h>

int execlp (const char *file,
            const char *arg,
            ...);

int execle (const char *path,
            const char *arg,
            ...,
            char * const envp[]);

int execv (const char *path, char *const argv[]);

int execvp (const char *file, char *const argv[]);

int execve (const char *filename,
            char *const argv[],
            char *const envp[]);
```

- exec 라는 기본 이름 뒤에 함수의 특징을 나타내는 알파벳이 뒤따름.
- exec 함수군 중에서 execve() 만 시스템 콜이고 다른 것들은 래퍼 함수임.
- 인자로 배열을 사용하면 인자를 실행 시간에 결정할 수 있다는 장점이 있음
- Q) 바로 위의 문장 무슨 뜻?
- Q)tip 으로 나온 execlp()와 execvp() 함수의 보안위험 무슨말?? 205페이지

## 5.3.2 fork() 시스템 콜

- fork 시스템 콜을 사용해서 현재 실행 중인 프로세스와 동일한 프로세스를 새롭게 실행할 수 있다.

```c
#include <sys/types.h>
#include <unistd.h>

pid_t fork (void);
```

- fork() 호출이 성공하면 fork() 를 실행한 프로세스와 거의 모든 내용이 동일한 새로운 프로세스를 생성함.
- 두 프로세스는 계속 실행 상태
- 성공 시 부모 프로세스에서는 fork() 시스템 콜의 반환값은 자식 프로세스의 pid가 됨.
- 필수적인 항목을 제외하고는 거의 모든 측면에서 자식,부모가 동일
  - 자식의 pid는 새롭게 할당됨
  - 자식의 ppid는 부모의 pid
  - 자식 프로세스에서 리소스 통계는 0으로 초기화됨
  - 처리되지 않은 시그널은 모두 사라지고 자식 프로세스로 상속되지 않음.
  - 부모가 가지고 있던 파일 락은 상속되지 않음
- 호출 실패 시 -1반환, errno 설정
- 예제

  ```c
  pid_t pid;

  pid = fork ();
  if (pid > 0)
          printf ("I am the parent of pid=%d!\n", pid);
  else if (!pid)
          printf ("I am the child!\n");
  else if (pid == −1)
          perror ("fork")
  ```

- 가장 흔한 예제는 새로운 프로세스를 생성하고 그 후에 새 프로세스에 새로운 바이너리 이미지를 올리는 것임.

  - 즉 ,fork() 하고 자식 프로세스는 exec 를 진행함
  - 예제

    ```c
    pid_t pid;

    pid = fork ();
    if (pid == −1)
            perror ("fork");

    /* the child ... */
    if (!pid) {
            const char *args[] = { "windlass", NULL };
            int ret;

            ret = execv ("/bin/windlass", args);
            if (ret == −1) {
                    perror ("execv");
                    exit (EXIT_FAILURE);
            }
    }
    ```

    - 부모 프로세스는 자식 프로세스가 생겼다는 사실 외에는 아무런 변화 없이 진행됨

### copy-on-write

- 기존에는 fork() 수행 시 페이지 단위로 복사했음
- 최신 유닉스 시스템은 주소 공간 모두 복사하는 것이 아니라 페이지에 대한 COW를 수행함.
- COW
  - 복사에 의한 부하를 완화하기 위한 최적화기법.
  - 자신이 가지고 있는 리소스의 읽기 요청이 들어오더라도 포인터만 넘겨받으면 된다는 전제에서 시작함.
  - 쓰기 작업을 할 경우에만 복사가 일어남.

### vfork()

- 쓸모없는 주소 공간 복사 문제를 해결하기 위한 옛날 노력
- fork()와 같은 동작을 하지만 자식 프로세스는 즉시 exec 계열의 함수를 성공적으로 호출하든가, \_exit() 함수를 호출해서 프로세스를 끝내야함
- vfork() 구현은 버그를 수반함
  - exec 호출이 실패할 경우는?
  - 자식 프로세스가 어떻게 처리해야할지 파악하거나 종료하기 전까지는 계속 멈춰있음.
  - Q) 요부분 다시 이해하기

# 5.4 프로세스 종료하기

```c
#include <stdlib.h>

void exit (int status);
```

- exit()을 호출하면 몇 가지 기본적인 종료 단계를 거쳐 커널이 프로세스를 종료함.
- 반환값이 없기 때문에 exit 호출 이후 명령은 의미가 없음
- 종료 순서
  1. atexit()이나 on_exit()에 등록된 함수가 있다면 등록 수선의 역순으로 호출
  2. 열려있는 모든 표준 입출력 스트림의 버퍼를 비운다.
  3. tmpfile() 함수를 통해 생성한 임시 파일을 삭제
- 프로세스가 사용자 영역에서 해야하는 모든 작업을 종료시킴.
- 마지막으로 exit()은 \_exit() 시스템 콜을 실행해서 나머지 단계를 커널이 처리하게 한다.
  - 프로세스가 종료되면 커널은 해당 프로세스가 생성한 더 사용되지 않는 모든 리소스를 정리한다.
- \_exit()을 직접 사용하면 표준 출력 스트림을 비우는 등의 사후 처리를 직접 해야한다.
  - vfork()를 사용하면 \_exit() 을 사용해야함.

## 5.4.1 프로세스를 종료하는 다른 방법

- 고전적인 방법은 시스템 콜을 사용하지 않고, 단순히 프로그램을 끝까지 진행시키는 것임
  - main() 함수가 반환되는 경우
  - 하지만 이런 경우도 컴파일러가 프로그램 종료 코드 이후에 exit() 시스템 콜을 묵시적으로 추가한다.
- SIGTERM 과 SIGKILL 을 보내서 종료도 가능
- 커널에 밉보이는 방법
  - 잘못된 연산 수행
  - 세그멘테이션 폴트 일으킴
  - 메모리 고갈
  - 리소스 과다 소모
  - → 프로세스를 강제로 죽임

## 5.4.2 atexit()

- atexit() 함수는 프로세스가 종료될 때 실행할 함수를 등록하기 위한 용도로 사용됨.

```c
#include <stdlib.h>

int atexit (void (*function)(void));
```

- 정상적으로 실행되면 프로세스가 정상적으로 종료될 때 호출할 함수를 등록함.
- 등록할 함수는 아무런 인자도 갖지 않고 어떠한 값도 반환하지 않는 함수여야함.
  - 이 함수들을 스택에 저장되며 LIFO 방식으로 실행됨.
  - 등록된 함수에서 exit()을 호출한다면 무한 루프에 빠진다. \_exit() 을 사용하자
- 예제

  ```c
  #include <stdio.h>
  #include <stdlib.h>

  void out (void)
  {
          printf ("atexit() succeeded!\n");
  }

  int main (void)
  {
          if (atexit (out))
                  fprintf(stderr, "atexit() failed!\n");

          return 0;
  }
  ```

## 5.4.3 on_exit()

- SunOS4 는 atexit()와 동일한 자신만의 함수를 정의하고 있으며, 리눅스의 glibc에서도 지원한다.

```c
#include <stdlib.h>

int on_exit (void (*function)(int, void *), void *arg);
```

- atexit()와 동일하게 동작하지만 등록할 수 있는 함수의 프로토 타입이 다름.

```c
void my_function (int status, void *arg);
```

## 5.4.4 SIGCHLD

- 프로세스가 종료될 때 커널은 SIGCHLD 시그널을 부모 프로세스로 보낸다.
- 기본적으로 부모 프로세스는 이 시그널을 무시하며 아무런 행동도 하지 않음.
- 하지만 프로세스는 signal() 이나 sigaction() 시스템 콜을 사용해서 처리한다.
- 부모 프로세스 관점에서는 자식 프로세스의 종료가 비동기로 일어남

# 5.5. 자식 프로세스 종료 기다리기

- 시그널을 통해 알림을 받는 방법도 훌륭하지만, 많은 부모 프로세스는 자식 프로세스 중 하나가 종료될 때 좀 더 많은 정보를 얻고자 함.
- 자식 프로세스가 완전히 사라져버리면 정보를 얻을 수 없어서, 유닉스 초기 설계자들은 자식 프로세스가 부모 프로세스보다 먼저 죽으면 자식 프로세스를 좀비 프로세스로 바꾸기로 함.
  - 아주 최소한의 기본적인 커널 자료구조만 가지고 있음.
  - 좀비프로세스는 부모 프로세스가 자신의 상태를 조사하도록 기다림.
  - 부모 프로세스가 종료된 자식 프로세스로부터 정보를 회수한 다음에야 공식적으로 종료됨.
- 리눅스 커널은 종료된 자식 프로세스에 대한 정보를 얻기 위해 몇 가지 인터페이스를 제공함
- wait()

```c
#include <sys/types.h>
#include <sys/wait.h>

pid_t wait (int *status);
```

- wait()을 호출하면 종료된 프로세스의 pid를 반환하며 에러가 발생한 경우 -1을 반환.
- 만약 자식 프로세스가 종료되지 않았다면 자식 프로세스가 종료될 때까지 블록됨. (대기 상태)
- 이미 종료된 상태라면 호출은 즉시 반환됨.
