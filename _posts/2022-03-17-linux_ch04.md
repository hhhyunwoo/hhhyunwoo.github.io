---
layout: post
title: "[Linux System Programming] Ch04 고급 버퍼 입출력 "
date: 2022-03-17
categories:
  - Trouble Shooting
tags:
  [
    blog,
    jekyll,
    jekyll theme,
    NexT theme,
    Computer Science,
    컴퓨터공학,
    개발,
    소프트웨어,
    지킬 테마,
    지킬 블로그 포스팅,
    GitHub Pages,
  ]
---

# [Ch04 고급 버퍼 입출력]

2장에서는 파일입출력의 근본일 뿐만 아니라, 리눅스에서 일어나는 모든 통신의 토대인 기본 입출력 시스템 콜을 배웠다.

3장에서는 기분 입출력 시스템 콜에 사용자 영역 버퍼링이 필요한 때를 알아보고 해법으로 C언어의 표준 입출력 라이브러리에 대해 공부했다.

4장에서는 리눅스의 고급 입출력 시스템 콜에 대해 알아본다.

### 벡터 입출력

- 한번의 호출로 여러 버퍼에서 데이터를 읽거나 쓸 수 있도록 해줌.
- 다양한 자료구조를 단일 입출력 트랜젝션으로 다룰 때 유용하다.

### epoll

- poll()과 select() 시스템 콜을 개선한 시스템 콜이다.
- 싱글 스레드에서 수백 개의 FD를 poll해야 하는 경우에 유용하다.

### 메모리맵 입출력

- 파일을 메모리에 맵핑해서 간단한 메모리 조작을 통해 파일 입출력을 수행함.
- 특정 패턴의 입출력에 유용하다.

### 파일 활용법 조언

- 프로세스에서 파일을 사용하려는 **의도**를 커널에게 제공할수 있도록 하여, 입출력 성능을 향상시킴.

### 비동기식 입출력

- 작업 완료를 기다리지 않는 입출력을 요청한다.
- 스레드를 사용하지 않고 동시에 입출력 부하가 많은 작업을 처리할 경우 유용함

# 4.1 벡터 입출력

- 한번의 시스템 콜을 사용해서 여러개의 버퍼 벡터에 쓰거나, 여러 개의 버퍼 벡터로 읽어 들일 때 사용하는 입출력 메서드
  - _2장의 표준 읽기와 쓰기는 `선형 입출력`이라고 함._
- 벡터 입출력의 장점
  - 좀 더 자연스러운 코딩 패턴 - 미리 정의된 구조체의 여러 필드에 걸쳐서 데이터가 분리되어 있는 경우, 벡터 입출력을 사용하면 직관적인 방법으로 조작할 수 있음
  - 효율 - 한번의 사용으로 여러번의 선형 입출력 연산을 대체할 수 있음
  - 성능 - 시스템 콜 호출 횟수 ⬇️, 내부적으로 최적화된 구현을 제공
  - 원자성 - 벡터 입출력 연산 중에 다른 프로세스가 끼어들 수 없음

## 4.1.1 readv() 와 writev()

- readv() 함수는 fd에서 데이터를 읽어서 count 개수만큼 iov 버퍼에 저장한다.

```c
ssize_t readv (int fd, const struct iovec *iov, int count);
```

- writev() 함수는 count 개수만큼 iov 버퍼에 있는 데이터를 fd에 기록함

```c
ssize_t writev(int fd, const struct iovec *iov, int count);
```

- readv()와 writev() 함수는 여러 개의 버퍼를 사용한다는 점에서 read(), write()와 구분됨
- `iovec` 구조체는 세그먼트라고 하는 독립적으로 분리된 버퍼를 나타낸다.

```c
struct iovec{
	void *iov_base; // 버퍼의 시작 포인터
	size_t iov_len; // 버퍼 크기 (바이트)
}
```

- 이런 세그먼트의 집합을 `벡터`라고 한다.
- 벡터의 각 세그먼트에는 데이터를 기록하거나 읽어올 메모리 공간의 주소와 크기가 저장되어 있다.
- 두 함수는 각 버퍼에 iov_len 바이트만큼 데이터를 채우거나 쓴 다음, 다음 버퍼로 넘어간다.
- 두 함수 모드 iov[0] 부터 시작해서 iov[1], 그리고 iov[count-1]까지 세그먼트 순서대로 동작한다.

### 반환값

- 두 함수는 호출이 성공했을 때 읽거나 쓴 `바이트 개수`를 반환함
  - **반환값은 반드시 count \* iov_len 값과 같아야함.**
- 에러 발생 시 `-1`을 반환, errno 를 설정
- 각각 read(), write() 시스템 콜에서 발생 가능한 모든 종류의 에러가 발생할 수 있음

  - 추가로 두 가지 에러 상황을 정의하고 있음

    1. 반환값의 자료형이 `ssize_t` 이기 때문에, 만약 count \* iov_len 값이 `SSIZE_MAX`보다 큰 경우에는 데이터가 전송되지 않고 -1을 반환하며 errno 는 `EINVAL`로 설정됨
    2. POSIX에서는 count가 0보다 크고 `IOV_MAX`(_리눅스에서는 현재 1024로 정의하고 있음_) 와 같거나 작아야 한다고 명시하고 있는데, 만약 count가 0이라면 readv()와 writev()는 0을 반환한다.

       만약 count 값이 `IOV_MAX`보다 크다면 데이터는 전송되지 않고 -1을 반환하며 errno는 `EINVAL`로 설정됨

### 최적 count 찾기

- 벡터 입출력 작업을 할 때 리눅스 커널에서는 각 세그먼트를 위해 내부 데이터 구조체를 반드시 할당하게 됨!
- 근데 이 할당은 count의 크기에 따라 동적으로 일어난다.
- 만약 count값이 크지 않다면 스택에 미리 만들어둔 작은 세그먼트 배열을 사용해서, 동적 할당이 일어나지 않도록한다. → 성능 개선! (아주 효율적으로 동작함)
- 그러니깐 벡터 입출력 연산을 사용할 때 세그먼트의 개수의 감이 오지 않는다면 8 이하로 시도~~

### 예제

- writev() 예제
- 3개의 벡터 세그먼트에 데이터를 쓰는 예제
  - 각각 크기가 다른 문자열을 담고 있음

```c
int main(){
    struct iovec iov[3];
    ssize_t nr;
    int fd, i;

    char *buf[] = {
        "aaa",
        "bbbb",
        "cccccc"
    };

    fd = open("buccaneer.txt", O_WRONLY | OCREAT | O_TRUNC);
    if (fd == -1)
        // error
        return 1;

    // 세 iovec 구조체 값을 채운다
    for (i = 0; i<3;i++){
        iov[i].iov_base = buf[i];
        iov[i].iov_len = strlen(buf[i]) + 1;
    }

    // 단 한번의 호출로 세 iovec 내용을 모두 쓴다
    nr = writev (fd, iov, 3);
    if (nr == -1 )
        //error
        return 1;
    printf("wrote %d bytes\n", nr);

    if (close(fd))
        //error
        return 1;

    return 0
}
```

- readv()예제

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/uio.h>

int main ()
{
        char foo[48], bar[51], baz[49];
        struct iovec iov[3];
        ssize_t nr;
        int fd, i;

        fd = open ("buccaneer.txt", O_RDONLY);
        if (fd == −1) {
                perror ("open");
                return 1;
        }

        /* set up our iovec structures */
        iov[0].iov_base = foo;
        iov[0].iov_len = sizeof (foo);
        iov[1].iov_base = bar;
        iov[1].iov_len = sizeof (bar);
        iov[2].iov_base = baz;
        iov[2].iov_len = sizeof (baz);

        /* read into the structures with a single call */
        nr = readv (fd, iov, 3);
        if (nr == −1) {
                perror ("readv");
                return 1;
        }

        for (i = 0; i < 3; i++)
                printf ("%d: %s", i, (char *) iov[i].iov_base);

        if (close (fd)) {
                perror ("close");
                return 1;
        }

        return 0;
}
```

- 구현

```c
#include <unistd.h>
#include <sys/uio.h>

ssize_t naive_writev (int fd, const struct iovec *iov, int count)
{
        ssize_t ret = 0;
        int i;

        for (i = 0; i < count; i++) {
                ssize_t nr;

                errno = 0;
                nr = write (fd, iov[i].iov_base, iov[i].iov_len);
                if (nr == −1) {
                        if (errno == EINTR)
                                continue;
                        ret = −1;
                        break;
                }
                ret += nr;
        }

        return ret;
}
```

- readv()와 writev()는 사용자 영역에서 단순 루프를 사용해서 구현할 수 있음!
- 사실 리눅스 커널 내부의 모든 입출력은 벡터 입출력이다.
  - read, write 구현 역시 하나짜리 세그먼트를 가지는 벡터 입출력으로 구현되어 있음.

# 4.2 epoll

- poll과 select 의 한계에 대해서 인지하면서 커널 2.6버전에서는 `epoll`(event poll) 이라는 기능이 추가되었음
- poll과 select
  - 실행할 때마다 전체 fd를 요구함
    - → 커널은 검사해야 할 모든 파일 리스트를 다 살펴봐야함.
    - → fd 리스트의 크기가 수백 ~ 수천까지 커지면 병목현상이 발생
- epoll은 실제로 검사하는 부분과 검사할 fd를 등록하는 부분을 분리해서 위의 문제를 해결함
- epoll은 세 가지 System call로 동작함
  1. epoll 컨텍스트를 초기화
  2. 검사해야 할 fd를 epoll 컨텍스트에 등록하거나 삭제함
  3. 실제 이벤트를 기다리도록 동작

## 4.2.1 새로운 epoll 인스턴스 생성하기

- epoll 컨텍스트는 epoll_create1()을 통해서 생성됨

```c
#include <sys/epoll.h>

int epoll_create1 (int flags);

/* deprecated. use epoll_create1() in new code. */
int epoll_create (int size);
```

- 호출이 성공하면 새로운 epoll 인스턴스를 생성하고 그 인스턴스와 연관된 fd를 반환한다.
  - 요 fd는 실제 파일과는 아무런 관계가 없고 epoll 기능을 사용하는 다음 호출에 사용되는 핸들일 뿐임.
- `flag` 인자는 epoll 동작을 조정하기 위한 것
  - 0을 쓰면 size 인자가 없어졌다는 점을 빼면 `epoll_create()`과 동일함!
  - 현재는 `EPOLL_CLOSEXEC` 만 유효함
  - 새 프로세스가 실행될 때 이 파일을 자동적으로 닫아준다.
- 에러가 발생하면 -1을 반환, errno를 설정

  - `EINVAL`
    - 잘못된 flags 인자
  - `EMFILE`
    - 사용자의 최대 파일 초과
  - `ENFILE`
    - 시스템의 최대 파일 초과
  - `ENOMEM`
    - 메모리 부족

- 사용예제

  ```c
  int epfd;

  epfd = epoll_create1 (0);
  if (epfd < 0)
          perror ("epoll_create1");
  ```

  - epoll_create1()에서 반환하는 fd는 폴링이 끝난 뒤에 반드시 close()로 닫아줘야한다.

## 4.2.2 epoll 제어

- epoll_ctl() 시스템 콜은 주어진 epoll 컨텍스트에 fd를 추가하거나 삭제할 때 사용한다.

  ```c
  #include <sys/epoll.h>

  int epoll_ctl (int epfd,
                 int op,
                 int fd,
                 struct epoll_event *event);
  ```

  ```c
  struct epoll_event {
          __u32 events;  /* events */
          union {
                  void *ptr;
                  int fd;
                  __u32 u32;
                  __u64 u64;
          } data;
  };
  ```

- epoll_ctl() 호출이 성공하면 해당 epoll 인스턴스는 epfd 파일 디스크립터와 연결된다.
- op 인자는 fd가 가리키는 파일에 대한 작업을 명시한다.
  - `EPOLL_CTL_ADD`
    - epfd와 연관된 epoll 인스턴스가 fd와 연관된 파일을 감시하도록 추가하며, 각 이벤트는 event 인자로 정의한다.
  - `EPOLL_CTL_DEL`
    - epfd와 연관된 epoll 인스턴스에 fd를 감시하지 않도록 삭제한다.
  - `EPOLL_CTL_MOD`
    - 기존에 감시하고 있는 fd에 대한 이벤트를 event에 명시된 내용으로 갱신한다.
- event 인자는 그 작업의 동작에 대한 설명을 담고 있다.
- epoll_event 구조체의 events 필드는 주어진 fd에서 감시할 이벤트의 목록을 담고 있음
  - 여러가지 이벤트를 OR로 묶을 수 있다.
  - `EPOLLERR`
    - 해당 파일에서 발생하는 에러 상황. (이 이벤트는 따로 저장하지 않아도 항상 감시함.)
  - `EPOLLET`
    - 파일을 감시할 때 에지 트리거를 사용한다. (기본 동작은 **레벨 트리거**)
  - `EPOLLHUP`
    - 파일에서 발생하는 Hangup을 감시한다. (이 이벤트는 따로 저장하지 않아도 항상 감시함.)
  - `EPOLLIN`
    - 파일 읽기가 지연되지 않고 바로 가능한지 감시한다.
  - `EPOLLONESHOT`
    - 이벤트 발생 후 파일을 한번 읽고 나면 더 이상 감시하지 않는다.
    - 이를 다시 활성화 하려면 EPOLL_CTL_MOD를 통해서 새로운 이벤트 값을 설정해야 한다.
  - `EPOLLOUT`
    - 파일 쓰기가 지연되지 않고 바로 가능한지 감시한다.
  - `EPOLLPRI`
    - 즉시 읽어야 할 OOB데이터가 있는지 감시한다.
    - _OOB (Out Of Band) : Urgent data. 순서를 무시하고 보내는 메시지_
- epoll_event 구조체의 data 필드는 사용자 데이터를 위한 필드이다.
  - 이 필드에 담긴 내용은 요청한 이벤트가 발생해서 사용자에게 반환될 때 함께 반환됨.
  - 일반적인 사용 예
    - event.data.fd를 fd로 채워서 이벤트가 발생했을 때 어떤 fd를 들여다 봐야 하는지 확인하는 용도
- 성공 시 0을 반환하고 실패 시 -1을 반환, errno 설정
- 예제 코드

  ```c
  struct epoll_event event;
  int ret;

  event.data.fd = fd; /* return the fd to us later (from epoll_wait) */
  event.events = EPOLLIN | EPOLLOUT;

  ret = epoll_ctl (epfd, EPOLL_CTL_ADD, fd, &event);
  if (ret)
          perror ("epoll_ctl");
  ```

- epfd와 연관된 fd에 설정된 기존 구독 이벤트를 변경하려면 아래와 같이 작성하면 됨

  ```c
  struct epoll_event event;
  int ret;

  event.data.fd = fd; /* return the fd to us later */
  event.events = EPOLLIN;

  ret = epoll_ctl (epfd, EPOLL_CTL_MOD, fd, &event);
  if (ret)
          perror ("epoll_ctl");
  ```

- 반대로 epoll 인스턴스 epfd에 등록된 fd에 연관된 기존 이벤트를 삭제하려면 아래와 같이!

  ```c
  struct epoll_event event;
  int ret;

  ret = epoll_ctl (epfd, EPOLL_CTL_DEL, fd, &event);
  if (ret)
          perror ("epoll_ctl");
  ```

- op 값이 EPOLL_CTL_DEL인 경우 이벤트 마스크가 없기 때문에 event 값이 NULL이 될 수도 있음.
  - 하지만, 호환성 문제 떄문에 유효한 포인터를 넘겨야함.

## 4.2.3 epoll로 이벤트 기다리기
