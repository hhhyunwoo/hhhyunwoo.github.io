---
layout: post
title: "[Linux System Programming] Ch10 시그널 "
date: 2022-07-10
categories:
  - Linux
tags:
  [
    blog,
    jekyll,
    jekyll theme,
    NexT theme,
    Computer Science,
    컴퓨터공학,
    개발,
    소프트웨어,
    지킬 테마,
    지킬 블로그 포스팅,
    GitHub Pages,
  ]
---

# [Ch10 시그널]
# Ch10 시그널

리눅스 환경에서 Robustness Test (강건성 테스트) 나 디버깅을 진행하다보면 여러가지 오류로 인해서 프로그램이 종료되는데, 이 때 Core dump가 있으면 디버깅에 유용하지만 로그만 남아 있는 경우도 있음. 

이 때 단서가 되는 부분이 `시그널`임

> 시그널은 `비동기 이벤트 처리`를 위한 메커니즘을 제공하는 `소프트웨어 인터럽트`이다.
> 

*Hardware interrupt : 외부에서 전기적 신호(이벤트)가 발생했을 때* 

*Software interrupt : CPU가 연산중에 어떠한 조건에 맞는 이벤트가 발생했을 때* 

- 유저가 Ctrl+C 를 눌러 시스템 외부에서 발생시키거나, 프로세스가 0으로 나누는 연산을 수행한 경우처럼 프로그램이나 커널 내부 작업 중에 발생할 수도 있다.
- 또는 IPC(Inter-Process Communication) 기법으로 프로세스간 시그널 송수신도 가능하다.

> 중요한 점은 이벤트가 비동기적으로 발생할 뿐만 아니라 해당 프로그램도 시그널을 비동기적으로 처리할 수 있다는 점.
> 
- 시그널 처리 함수는 커널에 등록되어 시그널이 전달되었을 때 그 함수가 비동기식으로 호출된다.
- → 프로세스 입장에서 일을 하고 있는 도중에 시그널이 오면 잠시 일을 멈추고 시그널에 대한 처리를 한 뒤 다시 본래의 일로 돌아온다는 의미

<img width="512" alt="image" src="https://user-images.githubusercontent.com/37402136/178134187-475aa1b8-35bd-4285-b829-caaedbe67681.png">


- 시그널 전달 가능 흐름
    - `Kernel → Process`
    - `Process → Process`
    - `Thread → Thread`

# 10.1 시그널 개념

### 시그널의 생명 주기

- 시그널 발생 → 커널은 해당 시그널을 전달 가능할 때까지 쌓아둠 → 커널은 가능한 시점에 적절하게 시그널을 처리
- 커널은 프로세스 요청에 따라 세 가지 동작 중 하나를 수행함.

---

### 시그널을 무시한다.

- 무시할 수 없는 시그널은 `SIGKILL` 과 `SIGSTOP` 두 가지
    - 시스템 관리자가 프로세스를 종료하거나 멈출 수 있어야 하기 떄문

### 시그널을 붙잡아 처리한다.

- 커널은 프로세스의 현재 코드 실행을 중단하고 이전에 등록했던 함수로 건너뛰어서 해당 함수를 실행함.
- `SIGINT` 와 `SIGTERM` 은 가장 흔하게 잡을 수 있는 시그널.
    - ex. 터미널 프로그램은 시그널을 잡아서 프롬프트로 다시 돌아간다.
    - ex. 프로그램이 종료되기 전에 SIGTERM을 붙잡아서 네트워크 연결을 끊거나, 임시파일 삭제 등 종료와 관련된 작업을 수행할 수 있음
- SIGKILL 과 SIGSTOP은 잡을 수 없다.

### 기본 동작을 수행한다.

- 기본 동작은 시그널에 따라 다름.
    - 대부분은 프로세스 종료
    

<img width="507" alt="image" src="https://user-images.githubusercontent.com/37402136/178134189-e44e5a5d-1bad-4ceb-bb5c-0dc70b0798b5.png">


- 시그널을 전달 받게 되면 진행중인 테스크를 잠시 중단하고, Signal Handler를 수행한 후 다시 프로세스로 돌아옴

<img width="739" alt="image" src="https://user-images.githubusercontent.com/37402136/178134190-300dbfb7-d605-4130-931d-fce1a7cd5b46.png">


- 내부적으로는 조금 더 복잡하게 동작함
- Signal을 처리하는 것은 Kernel 이지만, handler를 등록했다면 signal handler를 수행하기 위해서 다시 user 영역으로 돌아옴.
- handler를 호출하고 다시 Kernel 영역으로 돌아가서 본래 Task의 context를 이용해서 signal이 불린 시점으로 돌아감.

## 10.1.1 시그널 식별자

시그널은 모두 `<signal.h>` 파일에 정의되어 있음

- 시그널은 단순 양의 정수를 나타내는 선행처리기의 정의이다.

시그널 번호는 1(보통 `SIGHUP`)에서 시작해서 선형적으로 증가하고, 전체 시그널이 대략 31개지만 대다수 프로그램은 몇 개만 처리함. 

## 10.1.2 리눅스에서 지원하는 시그널

[Table 10-1. Signals](https://www.notion.so/0fca8ed0199e4966a677a43607e4d5cd)

### SIGABRT

- `abort()` 함수를 호출한 프로세스에 이 시그널을 보낸다. 프로세스는 종료되고 코어 파일을 생성함.
- *리눅스에서는 assert() 호출이 실패할 경우 abort()를 호출함*
    - `abort()` : 현재 상태를 core dump 하고 프로세스를 `비정상적`으로 종료하는 함수
    - `exit()` : `정상적`으로 종료하는 함수
    
    ```
    **core dump** : UNIX 계열에서 프로그램이 비정상적으로 종료되는 경우에 프로그램이 종료될 당시의 메모리 상태를 기록하여 생성된 파일. 디버깅 용도로 사용됨 
    ```
    

### SIGBUS

- 프로세스가 메모리 보호 이외에 다른 하드웨어 장애를 유발한 경우 커널에서 이 시그널을 보냄.
    - 프로세스가 `mmap()` 으로 만든 메모리 영역에 부적절하게 접근할 때 커널에서 이 시그널을 보냄

### SIGHUP

- **제어터미널 상에서 부모 프로세스가 죽거나 멈춘 게(`hangup`) 감지되면 `SIGHUP` 시그널을 보냄.**
- 세션의 터미널 접속이 끊어질 때마다 커널에서 해당 세션 리더에게 이 시그널을 보냄.
- 또한, 커널은 세션 리더가 종료될 때 foreground process 그룹에 속한 모든 프로세스에 이 시그널을 보냄.
- 기본동작
    - 이 시그널은 사용자의 로그아웃을 의미 → 프로세스 종료
    - 데몬프로세스일 경우 자신의 설정을 다시 읽도록 하는 의미
    - ex. 아파치에 SIGHUP 을 보내면 httpd.conf를 다시 읽음.
        - 데몬 프로세스는 제어 터미널이 없어서 정상적인 상황에서는 이 시그널을 절대 받을 수 없음.

### SIGINT

- 사용자가 인터럽트 문자(보통 Ctrl + C)를 입력했을 때 커널은 포어그라운드 프로세스 그룹에 속한 모든 프로세스에 이 시그널을 보냄.
- 기본동작
    - 프로세스 종료.
    - 하지만 프로세스에서 이 시그널을 붙잡아 처리할 수 있고, 일반적으로 종료 직전에 마무리 목적으로 사용

### SIGKILL

- `kill()` 시스템 콜에서 보냄
- 시스템 관리자가 프로세스를 무조건 종료하도록 만드는 방법을 제공
- 잡거나 무시할 수 없으며 결과는 항상 해당 프로세스의 종료

### SIGSEGV

- `세그멘테이션 위반`(Segmentation Violation) 에서 유래된 이름
- 유효하지 않은 메모리 접근을 시도하는 프로세스에 보냄
    - 맵핑되지 않은 메모리에 접근하거나,
    - 읽기를 허용하지 않는 메모리를 읽거나,
    - 메모리에서 실행 가능하지 않은 코드를 실행하거나,
    - 쓰기를 허용하지 않는 메모리에 쓰는 경우
- 기본동작
    - 프로세스의 종료와 코어 덤프 생성

### SIGSTOP

- `kill()` 에서만 보낸다.
- 무조건 프로세스를 정지시키며 잡을 수도 무시할 수도 없음.

### SIGWINCH

- 터미널 윈도우 크기가 변한 경우, 커널에서 포어그라운드 프로세스 그룹에 속한 모든 프로세스에 이 시그널을 보냄.
- 기본적으로는 무시하지만, 붙잡아 처리할 수 있음.

<img width="842" alt="image" src="https://user-images.githubusercontent.com/37402136/178134194-15c41298-d189-43b3-9aaf-dd60b87b67ef.png">


# 10.2 시그널 관리 기초

시그널 관리를 위한 가장 단순하면서도 오래된 인터페이스는 `signal()` 함수이다. 

```c
#include <signal.h>

typedef void (*sighandler_t)(int);

sighandler_t signal (int signo, sighandler_t handler);
```

- `signal()` 호출이 성공되면 `signo` 시그널을 받았을 때 수행할 현재 핸들러를 `handler`로 명시된 새로운 시그널 핸들러로 옮겨 해당 시그널을 처리한다.
- handler 함수는 일반 함수와는 달리 이 함수의 반환값을 받아 처리할 수 있는 곳이 없기 때문에 반드시 `void` 를 반환해야 한다.
    - 유일한 인자는 처리될 시그널의 시그널 식별자*(ex. SIGUSR2)* 를 나타내는 정수이다.

```c
void my_handler (int signo);
```

- 현재 프로세스에 대해 시그널을 무시하게 하거나 시그널을 기본 동작으로 재설정하는 용도로도 커널에 signal() 함수를 사용할 수 있음. *(handler 위치에 넣어줄 수 있음 )*
    - `SIG_DFL`
        - signo로 지정한 시그널에 대한 동작을 기본값으로 설정한다.
    - `SIG_IGN`
        - signo로 지정한 시그널을 무시한다.
- return
    - 해당 시그널의 이전 동작인 `시그널 핸들러에 대한 포인터` or `SIG_DFL`, `SIG_IGN` 을 반환
    - 에러 발생 시 `SIG_ERR` 반환

## 10.2.1 모든 시그널 기다리기

pause() 시스템 콜은 프로세스를 종료시키는 시그널을 받을 때까지 해당 프로세스를 잠재운다.

*(테스트와 디버깅에 유용함)*

```c
#include <unistd.h>

int pause (void);
```

- pause() 는 붙잡을 수 있는 시그널을 받았을 때만 반환되며 -1을 반환.
- 리눅스 커널에서 가장 단순한 시스템 콜 중 하나이다.
    1. 해당 프로세스를 인터럽트 가능한 잠들기 상태로 만듬
    2. 실행 가능한 다른 프로세스를 찾기 위해 `schedule()` 을 호출하여 리눅스 프로세스 스케줄러를 실행한다. 

### 예시

```c
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <signal.h>

/* handler for SIGINT and SIGTERM */
static void signal_handler (int signo)
{
        if (signo == SIGINT)
                printf ("Caught SIGINT!\n");
        else if (signo == SIGTERM)
                printf ("Caught SIGTERM!\n");
        else {
                /* this should never happen */
                fprintf (stderr, "Unexpected signal!\n");
                exit (EXIT_FAILURE);
        }
        exit (EXIT_SUCCESS);
}

int main (void)
{
        /*
         * Register signal_handler as our signal handler
         * for SIGINT.
         */
        if (signal (SIGINT, signal_handler) == SIG_ERR) {
                fprintf (stderr, "Cannot handle SIGINT!\n");
                exit (EXIT_FAILURE);
        }

        /*
         * Register signal_handler as our signal handler
         * for SIGTERM.
         */
        if (signal (SIGTERM, signal_handler) == SIG_ERR) {
                fprintf (stderr, "Cannot handle SIGTERM!\n");
                exit (EXIT_FAILURE);
        }

        /* Reset SIGPROF's behavior to the default. */
        if (signal (SIGPROF, SIG_DFL) == SIG_ERR) {
                fprintf (stderr, "Cannot reset SIGPROF!\n");
                exit (EXIT_FAILURE);
        }

        /* Ignore SIGHUP. */
        if (signal (SIGHUP, SIG_IGN) == SIG_ERR) {
                fprintf (stderr, "Cannot ignore SIGHUP!\n");
                exit (EXIT_FAILURE);
        }

        for (;;)
                pause ();

        return 0;
}
```

## 10.2.3 실행과 상속

- `fork() 시스템 콜`을 통해서 프로세스가 생성되면 자식 프로세스는 부모 프로세스의 시그널에 대한 동작을 상속받는다.
    - 대기 중인 시그널은 상속되지 않는데, 대기 중인 시그널은 특정 pid로 보낸 것이지, 자식 프로세스로 보낸 것이 아니기 때문.
- `exec 시스템 콜` 을 통해서 프로세스가 처음 생성되면 모든 시그널은 부모 프로세스가 이를 무시하는 경우를 제외하고 모두 기본 동작으로 설정 됨

[실행과 상속](https://www.notion.so/aa474aa44dc1474d886a2ed493caee63)

## 10.2.4 시그널 번호를 문자열에 맵핑하기

시그널 이름으로 코드를 작성하면 힘듦 

→ 시그널 번호를 시그널 이름의 문자열로 변환할 수 있음 

`sys_siglist`

```c
extern const char * const sys_siglist[];

static void signal_handler (int signo)
{
        printf ("Caught %s\n", sys_siglist[signo]);
}
```

- 최선의 선택
- 시스템에서 지원하는 시그널 이름을 담고 있는 문자열의 배열
- 시그널 번호를 색인으로 이용함

BSD에서 정의된 `psignal()` 인터페이스

```c
#include <signal.h>

void psignal (int signo, const char *msg);
```

- msg 인자로 전달한 문자열을 stderr에 출력하는데, 콜론과 공백 그리고 signo로 지정한 시그널 이름이 따라옴

더 나은 인더페이스 `strsignal()`

```c
#define _GNU_SOURCE
#include <string.h>

char * strsignal (int signo);
```

- signo로 지정한 시그널의 설명을 가리키는 포인터를 반환함
- 하지만 반환된 문자열은 다음에 `strsignal()` 을 호출하기 전까지만 유효하기 때문에 Thread-safe 하지 않다.
    
    > strsignal() uses a static buffer and is not thread safe. Use bsd_strsignal() for thread safety.
    > 

## 10.3 시그널 보내기

`kill()` 시스템 콜은 특정 프로세스에서 다른 프로세스로 시그널을 보낸다. 

```c
#include <sys/types.h>
#include <signal.h>

int kill (pid_t pid, int signo);
```

- pid가 0보다 큰 경우 (일반적)
    - pid가 가리키는 프로세스에 signo 시그널을 보냄
- pid 0
    - 호출한 프로세스의 프로세스 그룹에 속한 모든 프로세스에 signo 시그널을 보냄
- pid -1
    - 호출한 프로세스가 시그널을 보낼 권한이 있는 모든 프로세스에 signo를 보냄
    - 호출한 프로세스 자신과 `init`은 제외
- pid < -1
    - 프로세스 그룹 -pid 에 signo를 보냄

## 10.3.1 권한

다른 프로세스에 시그널을 보내기 위해서는 보내는 프로세스가 적절한 권한을 가지고 있어야함

- `CAP_KILL` 기능이 있는 (root process) 프로세스는 모든 프로세스에 시그널을 보낼 수 있음
- 이 기능이 없을 경우 프로세스의 유효 사용자 ID 나 실제 사용자 ID는 반드시 시그널을 받는 프로세스의 실제 사용자 ID나 저장된 사용자 ID와 유효해야함
    - → 즉, 사용자는 자신이 소유하고 있는 프로세스에만 시그널을 보낼 수 있음
    
    > `SIGCONT`(프로세스 정지 후 계속 수행) 에 대한 예외를 정의함.
    > 
- signo가 0 (null 시그널) 이라면 시그널을 보내진 않지만, 에러 검사는 수행하기 때문에 권한 체크가 가능함!

```c
int ret;

ret = kill (1722, 0);
if (ret)
        ; /* we lack permission */
else
        ; /* we have permission */
```

## 10.3.3 자신에게 시그널 보내기

`raise()` 함수는 자기 자신에게 시그널을 보낼 수 있는 간단한 방법을 제공함

```c
#include <signal.h>

int raise (int signo);
```

```c
raise (signo);
===
kill (getpid(), signo);
```

## 10.3.4 프로세스 그룹 전체에 시그널 보내기

프로세스 그룹 ID를 음수로 바꿔서 `kill()` 을 사용하는 것이 아니라 프로세스 그룹에 속한 모든 프로세스에 시그널을 보낼 수 있는 함수도 있음

```c
#include <signal.h>

int killpg (int pgrp, int signo); 
```

```c
killpg (pgrp, signo);
===
kill (-pgrp, signo);
```

# 10.4 재진입성 (Reenterancy)

- `Reenterant` 함수
    - 둘 이상의 스레드에 의해서 호출되었을 때, 호출된 순서에 상관없이 하나가 수행되고 난 다음 다른 함수 호출이 수행된 것처럼 제대로 된 결과를 반환해주는 함수를 의미
    - **interrupt handler** 와 **signal handler**에서 찾아볼 수 있음
    - `특성`
        - no static (or global) non-constant data
        - not return the address to static (or global) non-constant data
        - …
    - `예시`
        - function_a()가 호출되고 있는 도중 interrupt가 발생
        - interrupt_handler() 가 수행
        - interrupt_handler() 내부에서 function_a()를 다시 사용해도, 기존에 수행중이던 function_a() 의 수행 결과에 영향을 주면 안된다는 것이 Reenterancy 이다.
    - `Thread-safe` VS `Reenterancy`
        - Thread-safe : A Function that may be safely invoker soncurrently by multiple threads
            - 즉, 멀티 스레드 환경에서 올바른 결과를 내어주는 함수를 의미
        - 모든 reenterant 함수는 thread-safe 하지만, 모든 thread-safe 함수가 reenterant 함수인 것은 아니다.

커널이 시그널을 보낼 때, 프로세스는 코드 어디선가에서 실행 중인 상태이다. 

해당 시그널의 핸들러는 어떤 작업 도중에도 실행이 가능하다. 따라서 프로세스에 설정된 시그널 핸들러는 자신이 **실행하는 작업과 자신이 손대는 데이터(**`특히 Global Data 를 수정할 때`)**를 아주 조심스럽게 다뤄야 함** !

# 10.5 시그널 모음

ref. [https://d-yong.tistory.com/10](https://d-yong.tistory.com/10) / [http://slideplayer.com/slide/10812592/](http://slideplayer.com/slide/10812592/)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/18075a8c-9113-4a9e-830f-e966b07d9189/Untitled.png)