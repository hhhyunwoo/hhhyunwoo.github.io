<!DOCTYPE html><html lang="en" mode="light" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="[Linux System Programming] Ch06 고급 프로세스 관리" /><meta property="og:locale" content="en" /><meta name="description" content="[Ch06 고급 프로세스 관리]" /><meta property="og:description" content="[Ch06 고급 프로세스 관리]" /><link rel="canonical" href="https://hhhyunwoo.github.io//posts/linux_ch06/" /><meta property="og:url" content="https://hhhyunwoo.github.io//posts/linux_ch06/" /><meta property="og:site_name" content="Hans H. Kim" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-03-30T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[Linux System Programming] Ch06 고급 프로세스 관리" /><meta name="twitter:site" content="@twitter_username" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-07-10T15:41:43+09:00","datePublished":"2022-03-30T00:00:00+09:00","description":"[Ch06 고급 프로세스 관리]","headline":"[Linux System Programming] Ch06 고급 프로세스 관리","mainEntityOfPage":{"@type":"WebPage","@id":"https://hhhyunwoo.github.io//posts/linux_ch06/"},"url":"https://hhhyunwoo.github.io//posts/linux_ch06/"}</script><title>[Linux System Programming] Ch06 고급 프로세스 관리 | Hans H. Kim</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Hans H. Kim"><meta name="application-name" content="Hans H. Kim"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/newyork_hw.jpeg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Hans H. Kim</a></div><div class="site-subtitle font-italic">Machine Learning Engineer <br> <br> Keep Blizt and Be Simple</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/all-posts/" class="nav-link"> <i class="fa-fw fas fa-blog ml-xl-3 mr-xl-3 unloaded"></i> <span>POSTS</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/hhhyunwoo" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['hyunwoo.h.kim','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>[Linux System Programming] Ch06 고급 프로세스 관리 </span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>[Linux System Programming] Ch06 고급 프로세스 관리</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Hans H. Kim </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Mar 30, 2022, 12:00 AM +0900" >Mar 30, 2022<i class="unloaded">2022-03-30T00:00:00+09:00</i> </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Sun, Jul 10, 2022, 3:41 PM +0900" >Jul 10, 2022<i class="unloaded">2022-07-10T15:41:43+09:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="5874 words">32 min read</span></div></div><div class="post-content"><h1 id="ch06-고급-프로세스-관리">[Ch06 고급 프로세스 관리]</h1><ul><li>5장에서는 프로세스가 무엇인지, 생성, 제어, 종료에 관한 시스템 콜과 관련된 시스템에 대해 알아봤음.<li>이번 장에서는 리눅스 프로세스 스케줄러와 스케줄링 알고리즘을 알아본다.</ul><h1 id="61-프로세스-스케줄링">6.1 프로세스 스케줄링</h1><ul><li>프로세스 스케줄러는 커널의 서브 시스템으로써 유한한 리소스인 프로세서의 시간을 시스템 내의 프로세스에 나눠준다.<ul><li>즉, 다음에 실행할 프로세스를 선택하기 위한 커널의 구성요소임.</ul><li>실행 가능한 프로세스<ul><li>블록되지 않은 프로세스</ul><li>블록된 프로세스<ul><li>자고 있거나, 커널로부터 입출력을 기다리고 있는 프로세스</ul><li><p>프로세서의 개수보다 실행 가능한 프로세스가 더 많이 존재할 때는 스케줄러가 필요함</p><li>선점형 멀티태스킹<ul><li>리눅스<li>다른 프로세스를 위해 실행 중인 프로세스를 멈추는 행위를 선점이라고 함.<li>스케줄러가 선점하기 전까지 프로세스에 허락된 실행 시간을 프로세스 타임 슬라이스라고 한다.</ul><li>비선점형 멀티태스킹<ul><li>프로세스가 스스로 실행을 멈추기 전까지 계속 실행함.<li>자발적으로 실행을 잠시 쉬는 것을 <code class="language-plaintext highlighter-rouge">양보</code>라고 함<li>너무 오래 실행되는 그런 단점때문에 최신 OS는 거의 선점형 을 사용한다.</ul></ul><h2 id="611-타임-슬라이스">6.1.1 타임 슬라이스</h2><ul><li>스케줄러가 각 프로세스에 할당하는 타임 슬라이스는 시스템 전반의 동작 방식과 성능에 관한 중요한 변수이다.<li>타임 슬라이스가 너무 크다면 프로세스는 다음 실행 시간까지 오래 기다려야 하며, 동시 수행 능력을 떨어트림.<li>반대로 너무 작으면 잦은 프로세스 전환으로 인해 일시적인 지역성과 같은 장점을 잃게 됨.<li>목적에 따라 크기를 다르게한다.<ul><li>시스템이 처리할 수 있는 용량을 극대화하여 성능 향상을 하려고 큰 슬라이스를 사용함.<li>혹은 빠른 응답속도를 확보하기 위해서 작은 슬라이스를 사용함.<li>→ 이상적인 사이즈를 결정하기가 어려움!</ul></ul><h2 id="612-입출력-위주-프로세스와-cpu-위주-프로세스">6.1.2 입출력 위주 프로세스와 CPU 위주 프로세스</h2><ul><li>사용 가능한 타임 슬라이스를 끊임없이 계속 사용하는 프로세스를 CPU 위주 프로세스라고 한다.<ul><li>스케줄러에서 허락하는 시간을 모두 사용함</ul><li><p>예시</p><ul><li>무한루프<li>과학계산, 수학연산, 이미지 처리 등</ul><div class="language-bash highlighter-rouge"><div class="code-header"> <span text-data=" Shell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>// 100% processor-bound
<span class="k">while</span> <span class="o">(</span>1<span class="o">)</span>
  <span class="p">;</span>
</pre></table></code></div></div><li><p>실행 시간보다 리소스를 사용하기 위해 기다리는 시간을 더 많이 사용하는 프로세스를 IO 위주 프로세스 라고 한다.</p><ul><li>네트워크 입출력, 파일 입출력 기다림.<li>cp, mv 같은 파일 유틸리티 , User GUI 등.</ul><li>각각의 특성에 맞게 스케줄러를 선택해야함.<li>CPU 위주<ul><li>일시적인 지역성을 통해 캐시 적중률을 최대화하고 작업을 빨리 끝내기 위해 큰 타임 슬라이스를 사용</ul><li><p>IO 위주</p><ul><li>입출력 요청을 보내기까지 아주 짧은 시간이면 충분하고 대부분의 시간을 커널 리소스를 얻기 위해 블록되기 때문에 큰 슬라이스가 필요없음.</ul><li>현실에서는 CPU와 입출력을 같이 사용함</ul><h2 id="613-선점형-스케줄링">6.1.3 선점형 스케줄링</h2><ul><li>전통적인 유닉스 프로세스 스케줄링에서 모든 실행 가능한 프로세스는 타임 슬라이스를 할당받음<li>프로세스가 주어진 타임 슬라이스를 다 소진하면 커널은 그 프로세스를 잠시 멈추고 다른 프로세스를 실행.<li>→ 모든 프로세스는 자신보다 우선순위가 높은 프로세스가 있을지라도 그 프로세스가 타임 슬라이스를 모두 소진하거나 블록된다면 결국 실행될 기회를 얻게됨.<li>→ 모든 프로세스는 반드시 계속 진행되어야 한다는 규칙을 만들어냄</ul><h1 id="62-cfs-스케줄러">6.2 CFS 스케줄러</h1><ul><li>Completely Fair Scheduler<li>CFS 전의 전통 유닉스 시스템들은 <code class="language-plaintext highlighter-rouge">우선순위</code>와 <code class="language-plaintext highlighter-rouge">타임 슬라이스</code> 라는 변수를 사용해서 스케줄링을 구현했음<li>CFS는 타임 슬라이스 대신 CPU 시간의 일부를 각 프로세스에 할당한다.<ul><li>N개의 프로세스에 각각 <code class="language-plaintext highlighter-rouge">1/N</code> 만큼의 CPU 시간을 할당한다.<li>그리고 이를 각 프로세스의 <code class="language-plaintext highlighter-rouge">nice</code> 값에 따라 가중치를 준다.<li><code class="language-plaintext highlighter-rouge">nice</code> 값이 기본값인 <code class="language-plaintext highlighter-rouge">0</code>을 그대로 사용하는 프로세스의 가중치는 <code class="language-plaintext highlighter-rouge">1</code>이며, 따라서 할당받는 CPU 시간에는 변화가 없다.<li>기본값보다 적은 nice 값을 사용하는 (우선순위가 높은) 프로세스는 CPU 시간을 더 많이 할당 받음</ul><li>각 프로세스가 수행될 시간을 결정하기 위해 CFS 스케줄러는 프로세스 별로 가중치가 적용된 값을 한정된 시간(<code class="language-plaintext highlighter-rouge">Target Latency</code>) 로 나눈다.<ul><li>시스템의 스케줄링 레이턴시를 나타냄.<li>예시<ul><li>Target Latency : 20 밀리초<li>5개의 프로세스<li>→ 각 4밀리초<li>But, 프로세스가 많다면 Context Switching Overhead 때문에 일시적인 지역성의 효과는 줄어들고 시스템 전체 처리 성능은 매우 지장받음<ul><li>→이런 상황을 피하기 위해 CFS는 최소단위 (<code class="language-plaintext highlighter-rouge">Minimum Granularity</code>) 를 사용함</ul></ul></ul><li>최소 단위<ul><li>프로세스가 실행되는 최저 시간 단위<li>모든 프로세스는 할당된 CPU 시간과 관계없이 최소 단위만큼은 실행된다는 의미<li>근데 이를 사용하면 공정성이 무너짐!<ul><li>→ 납득할 수 있는 만큼의 평범한 상황에서는 최소 단위가 적용되지 않고, Target latency 만으로 공정성을 유지할 수 있다.</ul></ul></ul><h1 id="63-프로세서-양보하기">6.3 프로세서 양보하기</h1><ul><li>리눅스는 선점형 멀티태스킹 운영체제지만, 프로세스가 명시적으로 실행을 양보해서 스케줄러가 새로운 프로세스를 실행하도록 하는 시스템 콜을 제공한다.</ul><div class="language-bash highlighter-rouge"><div class="code-header"> <span text-data=" Shell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="c">#include &lt;sched.h&gt;</span>

int sched_yield <span class="o">(</span>void<span class="o">)</span><span class="p">;</span>
</pre></table></code></div></div><ul><li>sched_yield() 를 호출하면 현재 실행 중인 프로세스를 잠시 멈춘 다음 스케줄러가 다음에 실행할 새로운 프로세스를 선택하도록 한다.<li>다른 실행 가능한 프로세스가 없으면 sched_yield() 를 호출한 프로세스의 실행이 즉시 재개됨.<ul><li>→ 이런 불확실성과 일반적으로 더 나은 대안에 대한 믿음 때문에 이 시스템 콜은 잘 안씀.</ul></ul><h2 id="631-적당한-사용법">6.3.1 적당한 사용법</h2><ul><li>리눅스 커널은 가장 효율적이고 최적의 스케줄링 결정을 내리기에 부족함이 없음<li>→ 일개 어플리케이션이 무엇을 언제 선점해야 할지 결정하는 것보다 커널이 훨씬 더 나은 결정을 할 수 있음 !!<li>쓰는 경우가 있긴 하지만 잘 안씀.</ul><h1 id="64-프로세스-우선-순위">6.4 프로세스 우선 순위</h1><ul><li>nice 값은 프로세스가 <code class="language-plaintext highlighter-rouge">be nice</code> 하기를 바라면서 만들어짐.<li>-20 ~ 19 의 값을 가지고 있다.<li>값이 높을 수록 Nice 하기때문에 우선순위가 낮음.</ul><h2 id="641-nice">6.4.1 nice()</h2><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">nice</span> <span class="p">(</span><span class="kt">int</span> <span class="n">inc</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>호출이 성공하면 프로세스의 nice 값을 inc로 지정하고 새롭게 업데이트 된 값을 리턴한다.<li>오직 <code class="language-plaintext highlighter-rouge">CAP_SYS_NICE</code> 값을 가진 프로세스만 negative 값을 받을 수 있다.<ul><li>보통 root 만 이럼.</ul><li>결과적으로 non root 프로세스는 오직 우선순위를 낮출 수만 있음.<li>예시<div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

<span class="n">errno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">ret</span> <span class="o">=</span> <span class="n">nice</span> <span class="p">(</span><span class="mi">10</span><span class="p">);</span>    <span class="cm">/* increase our nice by 10 */</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="err">−</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">errno</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">perror</span> <span class="p">(</span><span class="s">"nice"</span><span class="p">);</span>
<span class="k">else</span>
        <span class="nf">printf</span> <span class="p">(</span><span class="s">"nice value is now %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
</pre></table></code></div></div><li>inc 값에 0을 넣으면 프로세스의 현재 nice 값을 알 수 있다.</ul><h2 id="642-getpriority-와-setpriority">6.4.2 getpriority() 와 setpriority()</h2><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;sys/time.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/resource.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">getpriority</span> <span class="p">(</span><span class="kt">int</span> <span class="n">which</span><span class="p">,</span> <span class="kt">int</span> <span class="n">who</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">setpriority</span> <span class="p">(</span><span class="kt">int</span> <span class="n">which</span><span class="p">,</span> <span class="kt">int</span> <span class="n">who</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prio</span><span class="p">);</span>
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">which</code><ul><li>PRIO_PROCESS<li>PRIO_PGRP<li>PRIO_USER<li>각각 who 값이 pid, pgid, uid를 판단한다.</ul><li>만약 who 가 0이면 현재 pid,pgid, uid를 받아옴.<li><code class="language-plaintext highlighter-rouge">getpriority()</code> 는 지정된 프로세스들 중에서 가장 높은 우선순위를 리턴함.<li><code class="language-plaintext highlighter-rouge">setpriority()</code> 는 <code class="language-plaintext highlighter-rouge">prio</code> 값으로 특정된 프로세스들 전부를 지정함.<li>예시<ul><li>현재 프로세스의 우선순위를 출력한다. ```c int ret;</ul><p>ret = getpriority (PRIO_PROCESS, 0); printf (“nice value is %d\n”, ret);</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Plaintext "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>- 현재 프로세스 그룹의 전체 프로세스의 우선순위를 10으로 지정한다.
```c
int ret;

ret = setpriority (PRIO_PGRP, 0, 10);
if (ret == −1)
        perror ("setpriority");
</pre></table></code></div></div></ul><h2 id="643-io-우선순위">6.4.3 I/O 우선순위</h2><ul><li>기본적으로 I/O 스케줄러는 프로세스의 nice 값을 기준으로 I/O 우선순위를 결정한다.</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">ioprio_get</span> <span class="p">(</span><span class="kt">int</span> <span class="n">which</span><span class="p">,</span> <span class="kt">int</span> <span class="n">who</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">ioprio_set</span> <span class="p">(</span><span class="kt">int</span> <span class="n">which</span><span class="p">,</span> <span class="kt">int</span> <span class="n">who</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ioprio</span><span class="p">)</span>
</pre></table></code></div></div><ul><li>glibc 는 지원하지 않음.</ul><h1 id="65-프로세서-친화">6.5 프로세서 친화</h1><ul><li>리눅스는 싱글 시스템에서 멀티프로세서를 지원함.<li>멀티프로세싱 머신에서 프로세스 스케줄러는 어떤 프로세스가 각 CPU에서 돌 것인지 판단해야만 한다.<li>프로세스가 놀 동안 CPU가 놀고 있으면 안됨.<li>프로세스가 한 CPU에 스케줄링 되고 다음에 다시 스케줄링 될 때 같은 CPU에 되어야함.<ul><li>migrating 부분에서 이점이 있음</ul><li>가장 큰 비용은 migration 할 때 캐쉬의 영향이다.<li>프로세스 스케줄러는 프로세스를 특정 CPU에 오랫동안 두어야함.</ul><h2 id="651-sched_getaffinity-와-sched_setaffinity">6.5.1 sched_getaffinity() 와 sched_setaffinity()</h2><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="cp">#define _GNU_SOURCE
</span>
<span class="cp">#include</span> <span class="cpf">&lt;sched.h&gt;</span><span class="cp">
</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">cpu_set_t</span><span class="p">;</span>

<span class="kt">size_t</span> <span class="n">CPU_SETSIZE</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">CPU_SET</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">cpu_set_t</span> <span class="o">*</span><span class="n">set</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">CPU_CLR</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">cpu_set_t</span> <span class="o">*</span><span class="n">set</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">CPU_ISSET</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">cpu_set_t</span> <span class="o">*</span><span class="n">set</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">CPU_ZERO</span> <span class="p">(</span><span class="n">cpu_set_t</span> <span class="o">*</span><span class="n">set</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">sched_setaffinity</span> <span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">setsize</span><span class="p">,</span>
                       <span class="k">const</span> <span class="n">cpu_set_t</span> <span class="o">*</span><span class="n">set</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">sched_getaffinity</span> <span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">setsize</span><span class="p">,</span>
                       <span class="n">cpu_set_t</span> <span class="o">*</span><span class="n">set</span><span class="p">);</span>
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">sched_getaffinity()</code> 는 프로세스 pid의 CPU 친밀도를 얻고 <code class="language-plaintext highlighter-rouge">cpu_set_t</code> 타입의 값에다가 저장한다.<li>만약 pid가 0이면 호출은 현재 프로세스의 affinity를 얻어옴.<li><code class="language-plaintext highlighter-rouge">setsize</code> 는 <code class="language-plaintext highlighter-rouge">cpu_set_t</code> 타입인데 타입의 사이즈 변화에 사용된다.<li>예제<div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="n">cpu_set_t</span> <span class="n">set</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

<span class="n">CPU_ZERO</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">set</span><span class="p">);</span>
<span class="n">ret</span> <span class="o">=</span> <span class="n">sched_getaffinity</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">cpu_set_t</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">set</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="err">−</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">perror</span> <span class="p">(</span><span class="s">"sched_getaffinity"</span><span class="p">);</span>

<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CPU_SETSIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

        <span class="n">cpu</span> <span class="o">=</span> <span class="n">CPU_ISSET</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">set</span><span class="p">);</span>
        <span class="n">printf</span> <span class="p">(</span><span class="s">"cpu=%i is %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
                <span class="n">cpu</span> <span class="o">?</span> <span class="s">"set"</span> <span class="o">:</span> <span class="s">"unset"</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>현재 프로세스의 affinity 를 출력한다.<div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">cpu</span><span class="o">=</span><span class="mi">0</span> <span class="n">is</span> <span class="n">set</span>
<span class="n">cpu</span><span class="o">=</span><span class="mi">1</span> <span class="n">is</span> <span class="n">set</span>
<span class="n">cpu</span><span class="o">=</span><span class="mi">2</span> <span class="n">is</span> <span class="n">unset</span>
<span class="n">cpu</span><span class="o">=</span><span class="mi">3</span> <span class="n">is</span> <span class="n">unset</span>
<span class="p">...</span>
<span class="n">cpu</span><span class="o">=</span><span class="mi">1023</span> <span class="n">is</span> <span class="n">unset</span>
</pre></table></code></div></div><li>두개의 프로세스가 돌아가는 상태일 때의 출력값<li>만약 0,1 중에서 0만 쓰고 싶다면,, ```c cpu_set_t set; int ret, i;</ul><p>CPU_ZERO (&amp;set); /* clear all CPUs <em>/ CPU_SET (0, &amp;set); /</em> allow CPU #0 <em>/ CPU_CLR (1, &amp;set); /</em> disallow CPU #1 */ ret = sched_setaffinity (0, sizeof (cpu_set_t), &amp;set); if (ret == −1) perror (“sched_setaffinity”);</p><p>for (i = 0; i &lt; CPU_SETSIZE; i++) { int cpu;</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Plaintext "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>    cpu = CPU_ISSET (i, &amp;set);
    printf ("cpu=%i is %s\n", i,
            cpu ? "set" : "unset"); } ``` # 6.6 실시간 시스템 - 실시간 : Time Limit 이 존재함. - Low latency or 빠른 응답시간 : 빠르면 빠를수록 좋은 것 - 예제   - Task A는 특정 기능을 1초안에 수행하지 않으면 전체 시스템에 치명적인 위해를 가할 수 있음.
- → Time limit : 1초.
- → 1초라는 시간을 준수하면서 특정 기능을 수행하는 것을 `실시간`이라고 함   - Task B는 기능을 수행함에 있어 Time Limit 은 없다.
- → 빠르면 좋긴하겠지만 느리다고 해서 치명적인 손상을 입히는 것은 아님. - 리눅스 기반의 Real-time OS   - 리눅스 기반의 RTOS와 일반 리눅스 OS는 크게 차이가 없다.
- 모든 OS는 preemptive 한 작업 수행을 보장함.   - **일반 리눅스는 interrupt가 들어왔을 때 현재 수행 중인 시스템 콜을 끝낸 뒤 Context switching**이 일어나지만, **RT 커널 기반의 리눅스는 현재 작업 중인 프로세스의 시스템 콜 수행마저도 Interrupt를 걸어 작업 Switching에 대한 Latency를 최소화**한다
</pre></table></code></div></div></ul><p><img data-proofer-ignore data-src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/94ceddfb-b437-4915-821b-42a6bf84a12d/Untitled.png" alt="Untitled" /></p><ul><li>일반 프로세스 레벨에서는 nice/renice를, RT 프로세스에서는 chrt를 쓰면됨.</ul><h2 id="661-hard-real-time-vs-soft-real-time-system">6.6.1 Hard Real-Time VS Soft Real-Time System</h2><ul><li>hard real-time system<ul><li>os의 데드라인을 무조건 따라야함.<li>데드라인을 넘어서는것은 제약적인 실패이고 큰 버그를 야기함.<li>예제<ul><li>ABS 시스템, 총기 시스템, 의료 장비, 시그널 프로세싱..</ul></ul><li>soft real-time system<ul><li>데드라인을 넘는 것을 크리티컬하다고 생각하지 않음.<li>예제<ul><li>비디오 프로세싱 애플리케이션<ul><li>데드라인이 넘어서 조금의 프레임이 깨져도 크게 영향이 없다.</ul></ul></ul></ul><h2 id="662-latency-jitter-and-deadlines">6.6.2 Latency, Jitter and Deadlines</h2><ul><li>Latency<ul><li>잠재적 시간 지연<li>응답에 대한 실행이 나타나기 까지의 시간을 의미<li>지연이 os 데드라인보다 작거나 같다면 잘 동작하는 것이다.</ul><li>Jitter<ul><li>응답간의 시차<li>지연 요소의 변동량. 즉, Latency 나 delay의 변화량 수준<li>연속적인 이벤트 간의 시간 편자는 레이턴시가 아니라 지터임.</ul></ul><h2 id="663-linuxs-real-time-support">6.6.3 Linux’s Real-Time Support</h2><ul><li>리눅스는 시스템 콜을 지원하여서 soft real-time 애플리케이션을 지원한다.</ul><h2 id="664-linux-scheduling-policies-and-priorities">6.6.4 Linux Scheduling Policies and Priorities</h2><ul><li>리눅스는 두가지 스케줄링 정책을 제공함.<li> <sched.h> 로부터 매크로를 제공받는다. </sched.h><ul><li><code class="language-plaintext highlighter-rouge">SCHED_FIFO</code>, <code class="language-plaintext highlighter-rouge">SCHED_RR</code>, <code class="language-plaintext highlighter-rouge">SCHED_OTHER</code></ul><li>모든 프로세스들은 nice 값이랑 별개로 static priority 를 가지고 있음.<ul><li>기본적으로 0이다.</ul><li>실시간 프로세스에서는 1-99까지의 값을 가진다.<li>일반적으로 <code class="language-plaintext highlighter-rouge">SCHED_OTHER</code> 를 사용함<ul><li>기본적으로 여러 프로세스 간 Time-sharing 방식(CFS Scheduler) 또는 우선순위 기반 스케줄링을 사용.</ul><li>FIFO, RR<ul><li>RT를 위한</ul></ul><h3 id="fifo-전략">FIFO 전략</h3><ul><li>FIFO는 timeslices가 없는 매우 심플한 실시간 전략이다.<li>더 높은 우선순위를 가진 프로세스가 없는 한 계속 진행한다.<li><code class="language-plaintext highlighter-rouge">SCHED_FIFO</code> 매크로를 사용함<li>정책에 타임슬라이스가 없기 때문에 비교적 간단하다.<ul><li>프로세스가 가장 높은 우선순위에 있다면 항상 실행됨.<li>프로세스가 블록되거나 <code class="language-plaintext highlighter-rouge">sched_yield()</code> 가 실행되거나, 더 높은 우선순위의 프로세스가 들어오기 전까지 계속 실행됨.</ul><li>Q) 같은 우선순위의 프로세스들이 있다면?</ul><h3 id="rount-robin-전략">Rount-Robin 전략</h3><ul><li>FIFO 클래스와 동일하지만 같은 우선순위일 때 추가적인 전략들이 있다.<li><code class="language-plaintext highlighter-rouge">SCHED_RR</code> 매크로를 사용<li>스케줄러는 RR-classed 프로세스 각각에 타임 슬라이스를 배정한다.<li>프로세스가 자신의 타임슬라이스를 다 쓰면 스케줄러는 그 프로세스를 우선순위 리스트에 끝으로 보낸다.<li>주어진 우선순위에 프로세스가 하나밖에 없다면 RR은 FIFO 와 동일하다.<li>RR 또한 같은 우선순위의 프로세스들 중에서 스케줄링을 계속 하기 때문에 FIFO와 거의 유사함.</ul><h3 id="normal-전략">Normal 전략</h3><ul><li><code class="language-plaintext highlighter-rouge">SCHED_OTHER</code> 은 기복적인 스케줄링 전략을 대표한다. (default non-real-time class)<li>모든 normal-classed 프로세스는 고정된 우선순위 값으로 0을 가지고 있다.<li>결과적으로 동작중인 FIFO or RR 프로세스들은 normal 프로세스를 점유할 것이다.<li>이 스케줄러는 nice 값을 사용함.</ul><h3 id="batch-스케줄링-전략">Batch 스케줄링 전략</h3><ul><li><code class="language-plaintext highlighter-rouge">SCHED_BATCH</code> 는 Batch or idle 스케줄링 전략이다.<li>real-time과 어느정도는 반대된다.<li>다른 프로세스들이 타임슬라이스를 다 썼더라도, 시스템에 동작 가능한 프로세스가 있다면 실행하지 않는다.</ul><h3 id="linux-스케줄링-전략-설정하기">Linux 스케줄링 전략 설정하기</h3><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;sched.h&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="n">sched_param</span> <span class="p">{</span>
        <span class="cm">/* ... */</span>
        <span class="kt">int</span> <span class="n">sched_priority</span><span class="p">;</span>
        <span class="cm">/* ... */</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">sched_getscheduler</span> <span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">sched_setscheduler</span> <span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">,</span>
                        <span class="kt">int</span> <span class="n">policy</span><span class="p">,</span>
                        <span class="k">const</span> <span class="k">struct</span> <span class="n">sched_param</span> <span class="o">*</span><span class="n">sp</span><span class="p">);</span>
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">sched_getscheduler()</code> 와 <code class="language-plaintext highlighter-rouge">sched_setscheduler()</code> 를 사용해서 리눅스 스케줄링 값을 조작할 수 있다.<li><code class="language-plaintext highlighter-rouge">sched_getscheduler()</code> 호출이 성공하면 pid 프로세스의 스케줄링 전략을 리턴한다.<li>pid가 0이면 호출을 실행한 프로세스의 스케줄링 정책이 반환됨.<li>예시<div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">policy</span><span class="p">;</span>

<span class="cm">/* get our scheduling policy */</span>
<span class="n">policy</span> <span class="o">=</span> <span class="n">sched_getscheduler</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="k">switch</span> <span class="p">(</span><span class="n">policy</span><span class="p">)</span> <span class="p">{</span>
<span class="k">case</span> <span class="n">SCHED_OTHER</span><span class="p">:</span>
        <span class="n">printf</span> <span class="p">(</span><span class="s">"Policy is normal</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
<span class="k">case</span> <span class="n">SCHED_RR</span><span class="p">:</span>
        <span class="n">printf</span> <span class="p">(</span><span class="s">"Policy is round-robin</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
<span class="k">case</span> <span class="n">SCHED_FIFO</span><span class="p">:</span>
        <span class="n">printf</span> <span class="p">(</span><span class="s">"Policy is first-in, first-out</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
<span class="k">case</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">perror</span> <span class="p">(</span><span class="s">"sched_getscheduler"</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
<span class="nl">default:</span>
        <span class="n">fprintf</span> <span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Unknown policy!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><li><code class="language-plaintext highlighter-rouge">sched_setscheduler()</code> 를 호출하면 pid 에다가 policy를 넣어준다.<li><code class="language-plaintext highlighter-rouge">sp</code><ul><li>정책과 관련된 다른 파라미터들을 넣어주는 곳<li><code class="language-plaintext highlighter-rouge">shced_param</code><ul><li>구조 안의 유효한 값들은 policy에 따라 다름.<li>SCHED_RR과 SCHED_FIFO 는 sched_priority가 필요하고 SCHED_OTHER는 필요없음.</ul></ul><li>예시<ul><li>이 예시는 RR 정책으로 static priority를 1로 수정한다. ```c struct sched_param sp = { .sched_priority = 1 }; int ret;</ul><p>ret = sched_setscheduler (0, SCHED_RR, &amp;sp); if (ret == −1) { perror (“sched_setscheduler”); return 1; } ```</p><li>스케줄링 정책을 지정할 때 SCHED_OTHER를 제외하고는 <code class="language-plaintext highlighter-rouge">CAP_SYS_NICE</code> 설정이 필요하다.</ul><h2 id="665-스케줄링-파라미터-설정하기">6.6.5 스케줄링 파라미터 설정하기</h2><ul><li>POSIX는 스케줄링 정책과 관련된 파라미터들을 설정하고 가져올 수 있게 하기 위해서 <code class="language-plaintext highlighter-rouge">sched_getparam()</code> 과 <code class="language-plaintext highlighter-rouge">sched_setparam()</code> 을 지원한다.</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;sched.h&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="n">sched_param</span> <span class="p">{</span>
        <span class="cm">/* ... */</span>
        <span class="kt">int</span> <span class="n">sched_priority</span><span class="p">;</span>
        <span class="cm">/* ... */</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">sched_getparam</span> <span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_param</span> <span class="o">*</span><span class="n">sp</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">sched_setparam</span> <span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sched_param</span> <span class="o">*</span><span class="n">sp</span><span class="p">);</span>
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">sched_getscheduler()</code> 호출은 오직 스케줄링 정책만 리턴하지만 <code class="language-plaintext highlighter-rouge">sched_getparam()</code> 은 sp에다가 pid 프로세스와 연관된 스케줄링 파라미터들을 전달한다.<li>예시<div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">sched_param</span> <span class="n">sp</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

<span class="n">ret</span> <span class="o">=</span> <span class="n">sched_getparam</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sp</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="err">−</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span> <span class="p">(</span><span class="s">"sched_getparam"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">printf</span> <span class="p">(</span><span class="s">"Our priority is %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">sp</span><span class="p">.</span><span class="n">sched_priority</span><span class="p">);</span>
</pre></table></code></div></div><li>만약 pid가 0이면 호출한 프로세스의 파라미터를 넘김.<li><code class="language-plaintext highlighter-rouge">sched_setscheduler()</code> 또한 스케줄링 파라미터를 저장하긴 하지만, <code class="language-plaintext highlighter-rouge">sched_setparam()</code> 은 나중에 파라미터를 변경할 때 유용하다.<li>예시<div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">sched_param</span> <span class="n">sp</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

<span class="n">sp</span><span class="p">.</span><span class="n">sched_priority</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">ret</span> <span class="o">=</span> <span class="n">sched_setparam</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sp</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="err">−</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span> <span class="p">(</span><span class="s">"sched_setparam"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div></ul><h3 id="유효한-우선순위-값-범위-결정하기">유효한 우선순위 값 범위 결정하기</h3><ul><li>리눅스에서는 1-99 값의 범위로 RT 스케줄링 정책을 지원한다.<li>리눅스는 현재 유효한 우선순위 값을 알기 위해서 시스템 콜을 지원한다.</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;sched.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">sched_get_priority_min</span> <span class="p">(</span><span class="kt">int</span> <span class="n">policy</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">sched_get_priority_max</span> <span class="p">(</span><span class="kt">int</span> <span class="n">policy</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>각각 유효한 우선순위 값의 최소값과 최대값을 리턴함.<li><code class="language-plaintext highlighter-rouge">policy</code><ul><li>스케줄링 정책을 넣어줌</ul><li>예시<div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">;</span>

<span class="n">min</span> <span class="o">=</span> <span class="n">sched_get_priority_min</span> <span class="p">(</span><span class="n">SCHED_RR</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">min</span> <span class="o">==</span> <span class="err">−</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span> <span class="p">(</span><span class="s">"sched_get_priority_min"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">max</span> <span class="o">=</span> <span class="n">sched_get_priority_max</span> <span class="p">(</span><span class="n">SCHED_RR</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">max</span> <span class="o">==</span> <span class="err">−</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span> <span class="p">(</span><span class="s">"sched_get_priority_max"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">printf</span> <span class="p">(</span><span class="s">"SCHED_RR priority range is %d - %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>
</pre></table></code></div></div></ul><h2 id="666-sched_rr_get_interval">6.6.6 sched_rr_get_interval()</h2><ul><li>SCHED_RR은 time slice를 사용한다는 것을 제외하고 SCHED_FIFO와 동일하게 작동한다.<li>만약 SCHED_RR 프로세스가 타임슬라이스를 다 썼다면, 스케줄러는 현재 우선순위의 동작 리스트 중 가장 마지막으로 간다.<li>이런 방법에서는 같은 우선순위의 모든 SCHED_RR 프로세스들은 Rount robin 으로 순회한다.<li><p>높은 우선순위의 프로세스들 (SCHED_FIFO of the same or higher priority) 은 SCHED_RR 프로세스의 타임슬라이스가 더 남았건 상관안하고 점유한다.</p><li>POSIX 는 주어진 프로세스의 timeslice의 길이를 얻을 수 있는 인터페이스를 제공한다.</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;sched.h&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="n">timespec</span> <span class="p">{</span>
        <span class="kt">time_t</span>  <span class="n">tv_sec</span><span class="p">;</span>     <span class="cm">/* seconds */</span>
        <span class="kt">long</span>    <span class="n">tv_nsec</span><span class="p">;</span>    <span class="cm">/* nanoseconds */</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">sched_rr_get_interval</span> <span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">tp</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>호출이 성공하면 timespec 구조의 tp에다가 pid에 할당된 타임슬라이스의 길이를 저장한다.<li>POSIX에 따르면 이 함수는 SCHED_RR에만 사용할 수 있지만, 리눅스에서는 어떤 프로세스든 적용할 수 있다.<li>예시<div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">timespec</span> <span class="n">tp</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

<span class="cm">/* get the current task's timeslice length */</span>
<span class="n">ret</span> <span class="o">=</span> <span class="n">sched_rr_get_interval</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tp</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="err">−</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span> <span class="p">(</span><span class="s">"sched_rr_get_interval"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* convert the seconds and nanoseconds to milliseconds */</span>
<span class="n">printf</span> <span class="p">(</span><span class="s">"Our time quantum is %.2lf milliseconds</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
        <span class="p">(</span><span class="n">tp</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">tp</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">/</span> <span class="mi">1000000</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">));</span>
</pre></table></code></div></div><ul><li>만약 프로세스가 FIFO 로 돌고있다면 tv_sec과 tv_nsec는 둘 다 0이다.</ul></ul><h2 id="667-real-time-프로세스의-주의점">6.6.7 Real-time 프로세스의 주의점</h2><h2 id="668-determinism-결정론">6.6.8 Determinism (결정론)</h2><ul><li>RT 프로세스는 결정론에 크게 좌지우지 한다.<li>RT 컴퓨팅에서 행동은 결정론적인데, 만약 같은 인풋을 받았을 때 항상 같은 양의 시간에 같은 결과를 만들어야하기 때문.<li>최신 컴퓨터는 결정론적이지 않은데, 여러 계층에 걸친 캐시와 여러 개의 프로세스, 페이징, 스와핑, 그리고 멀티태스킹은 명령이 얼마나 걸릴지 예측할 수 없음<li>실시간 애플리케이션은 예측할 수 없는 부분과 최악의 지연을 제한하려고 시도한다.</ul><h3 id="선행-폴트-데이터와-메모리-락">선행 폴트 데이터와 메모리 락</h3><ol><li>종종 선행 폴트를 일으켜 스왑된 데이터를 메모리에 올린 다음, 주소 공간 내 모든 페이지를 실제 물리 메모리에 ‘락을 걸거나’, ‘고정 배선’한다.<li>메모리 락을 걸고 나면 커널은 절대로 이 페이지를 디스크로 스왑하지 않는다.</ol><h3 id="cpu-친화도와-실시간-프로세스">CPU 친화도와 실시간 프로세스</h3><ol><li>각 실시간 프로세스를 위해 프로세서 하나를 예약해두고 나머지 프로세스는 남은 프로세서상에서 시분할 방식으로 동작하게 한다.<li>구현 방법:<ol><li>init 프로그램을 수정 - <code class="language-plaintext highlighter-rouge">CPU_CLR (1, &amp;set)</code>: CPU #1을 금지한다.<ol><li>실행 가능한 프로세서 집합은 부모 프로세스로부터 상속받게 된다.</ol><li>실시간 프로세스가 CPU #1에서만 실행되도록 affinity를 준다. - <code class="language-plaintext highlighter-rouge">CPU_SET (1, %set)</code></ol></ol></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/linux/'>Linux</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/blog/" class="post-tag no-text-decoration" >blog</a> <a href="/tags/jekyll/" class="post-tag no-text-decoration" >jekyll</a> <a href="/tags/jekyll-theme/" class="post-tag no-text-decoration" >jekyll theme</a> <a href="/tags/next-theme/" class="post-tag no-text-decoration" >NexT theme</a> <a href="/tags/computer-science/" class="post-tag no-text-decoration" >Computer Science</a> <a href="/tags/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B3%B5%ED%95%99/" class="post-tag no-text-decoration" >컴퓨터공학</a> <a href="/tags/%EA%B0%9C%EB%B0%9C/" class="post-tag no-text-decoration" >개발</a> <a href="/tags/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4/" class="post-tag no-text-decoration" >소프트웨어</a> <a href="/tags/%EC%A7%80%ED%82%AC-%ED%85%8C%EB%A7%88/" class="post-tag no-text-decoration" >지킬 테마</a> <a href="/tags/%EC%A7%80%ED%82%AC-%EB%B8%94%EB%A1%9C%EA%B7%B8-%ED%8F%AC%EC%8A%A4%ED%8C%85/" class="post-tag no-text-decoration" >지킬 블로그 포스팅</a> <a href="/tags/github-pages/" class="post-tag no-text-decoration" >GitHub Pages</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=[Linux System Programming] Ch06 고급 프로세스 관리 - Hans H. Kim&url=https://hhhyunwoo.github.io//posts/linux_ch06/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=[Linux System Programming] Ch06 고급 프로세스 관리 - Hans H. Kim&u=https://hhhyunwoo.github.io//posts/linux_ch06/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=[Linux System Programming] Ch06 고급 프로세스 관리 - Hans H. Kim&url=https://hhhyunwoo.github.io//posts/linux_ch06/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/blog-newjourney/">🏢 첫번째 퇴사, 첫번째 이직</a><li><a href="/posts/k8s-nginx-413-error/">[K8S] Ingress Nginx 413 http error (payload too large) 이슈 해결</a><li><a href="/posts/infiniband-nccl-issue/">[Infiniband] NCCL WARN Call to ibv_reg_mr failed 이슈 해결</a><li><a href="/posts/k8s_service/">[Kubernetes] Kubernetes 서비스 정리(ClusterIP, Nodeport, Loadbalancer) </a><li><a href="/posts/k8s-kernel-epoll-etcd-leader/">[K8S] 5.4.0-132 커널의 epoll 버그로 인한 etcd leader election 이슈</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/blog/">blog</a> <a class="post-tag" href="/tags/github-pages/">GitHub Pages</a> <a class="post-tag" href="/tags/jekyll-theme/">jekyll theme</a> <a class="post-tag" href="/tags/jekyll/">jekyll</a> <a class="post-tag" href="/tags/next-theme/">NexT theme</a> <a class="post-tag" href="/tags/%EC%A7%80%ED%82%AC-%EB%B8%94%EB%A1%9C%EA%B7%B8-%ED%8F%AC%EC%8A%A4%ED%8C%85/">지킬 블로그 포스팅</a> <a class="post-tag" href="/tags/%EC%A7%80%ED%82%AC-%ED%85%8C%EB%A7%88/">지킬 테마</a> <a class="post-tag" href="/tags/computer-science/">Computer Science</a> <a class="post-tag" href="/tags/%EA%B0%9C%EB%B0%9C/">개발</a> <a class="post-tag" href="/tags/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4/">소프트웨어</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/docker/"><div class="card-body"> <span class="timeago small" >Feb 7, 2022<i class="unloaded">2022-02-07T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Docker] Centos Image 에서 sudo command not found 에러</h3><div class="text-muted small"><p> Centos Image 에서 sudo command not found centos/python-36-centos7 이미지 사용 도중 Dockerfile 내부에서 커맨드로 파일의 모드를 바꿔야할 일이 생겼다. RUN sudo chmod 755 start.sh 근데 sudo 를 실행했을 떄 /bin/sh: sudo: command not fo...</p></div></div></a></div><div class="card"> <a href="/posts/First-post/"><div class="card-body"> <span class="timeago small" >Nov 12, 2021<i class="unloaded">2021-11-12T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>First Post</h3><div class="text-muted small"><p> Welcome Hello world, this is my first Jekyll blog post. I hope you like it!</p></div></div></a></div><div class="card"> <a href="/posts/tb07-jekyll-bundler-error/"><div class="card-body"> <span class="timeago small" >Nov 13, 2021<i class="unloaded">2021-11-13T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Trouble Shooting] Jekyll chirpy 템플릿으로 Github 블로그 시작하기. (Bundler Install Error)</h3><div class="text-muted small"><p> Jekyll chirpy 템플릿으로 Github 블로그 시작하기. (Bundler Install Error) Github 블로그 with Chirpy Jekyll Theme github 블로그를 시작할 때 Jekyll을 많이 사용한다. 그럼 Jekyll이 무엇일까? Jekyll? 텍스트 변환 엔진으로, Markup 언어로 글을 작성하면 이...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/linux_ch05/" class="btn btn-outline-primary" prompt="Older"><p>[Linux System Programming] Ch05 프로세스 관리</p></a> <a href="/posts/miracle00/" class="btn btn-outline-primary" prompt="Newer"><p>[미라클모닝][MKYU] 514 서약서</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://github.com/hhhyunwoo">Hans H. Kim</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/blog/">blog</a> <a class="post-tag" href="/tags/github-pages/">GitHub Pages</a> <a class="post-tag" href="/tags/jekyll-theme/">jekyll theme</a> <a class="post-tag" href="/tags/jekyll/">jekyll</a> <a class="post-tag" href="/tags/next-theme/">NexT theme</a> <a class="post-tag" href="/tags/%EC%A7%80%ED%82%AC-%EB%B8%94%EB%A1%9C%EA%B7%B8-%ED%8F%AC%EC%8A%A4%ED%8C%85/">지킬 블로그 포스팅</a> <a class="post-tag" href="/tags/%EC%A7%80%ED%82%AC-%ED%85%8C%EB%A7%88/">지킬 테마</a> <a class="post-tag" href="/tags/computer-science/">Computer Science</a> <a class="post-tag" href="/tags/%EA%B0%9C%EB%B0%9C/">개발</a> <a class="post-tag" href="/tags/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4/">소프트웨어</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-EPY53PE167"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-EPY53PE167'); }); </script>
