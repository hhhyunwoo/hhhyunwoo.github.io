<!DOCTYPE html><html lang="en" mode="light" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="[Linux System Programming] Ch03 버퍼 입출력" /><meta property="og:locale" content="en" /><meta name="description" content="[Ch03 버퍼 입출력]" /><meta property="og:description" content="[Ch03 버퍼 입출력]" /><link rel="canonical" href="https://hhhyunwoo.github.io//posts/linux_ch03/" /><meta property="og:url" content="https://hhhyunwoo.github.io//posts/linux_ch03/" /><meta property="og:site_name" content="Hans H. Kim" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-03-13T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[Linux System Programming] Ch03 버퍼 입출력" /><meta name="twitter:site" content="@twitter_username" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-07-10T15:41:43+09:00","datePublished":"2022-03-13T00:00:00+09:00","description":"[Ch03 버퍼 입출력]","headline":"[Linux System Programming] Ch03 버퍼 입출력","mainEntityOfPage":{"@type":"WebPage","@id":"https://hhhyunwoo.github.io//posts/linux_ch03/"},"url":"https://hhhyunwoo.github.io//posts/linux_ch03/"}</script><title>[Linux System Programming] Ch03 버퍼 입출력 | Hans H. Kim</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Hans H. Kim"><meta name="application-name" content="Hans H. Kim"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/newyork_hw.jpeg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Hans H. Kim</a></div><div class="site-subtitle font-italic">Machine Learning Engineer <br> <br> Keep Blizt and Be Simple</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/all-posts/" class="nav-link"> <i class="fa-fw fas fa-blog ml-xl-3 mr-xl-3 unloaded"></i> <span>POSTS</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/hhhyunwoo" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['hyunwoo.h.kim','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>[Linux System Programming] Ch03 버퍼 입출력 </span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>[Linux System Programming] Ch03 버퍼 입출력</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Hans H. Kim </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sun, Mar 13, 2022, 12:00 AM +0900" >Mar 13, 2022<i class="unloaded">2022-03-13T00:00:00+09:00</i> </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Sun, Jul 10, 2022, 3:41 PM +0900" >Jul 10, 2022<i class="unloaded">2022-07-10T15:41:43+09:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="7835 words">43 min read</span></div></div><div class="post-content"><h1 id="ch03-버퍼-입출력">[Ch03 버퍼 입출력]</h1><blockquote><p><strong>블록</strong> : 파일 시스템의 최소 저장 단위를 나타내는 추상 개념. 파일 시스템 연산은 블록 단위로 일어난다. (데이터에 필요한 블록이 4.5개라 하더라도 5개를 써야함.)</p></blockquote><p>→ 블록의 일부분만 다루는 연산이 비효율적임.</p><h1 id="31-사용자-버퍼-입출력">3.1 사용자 버퍼 입출력</h1><ul><li>일반 파일에 대해 잦은 입출력을 처리해야만 하는 프로그램은 종종 <code class="language-plaintext highlighter-rouge">사용자 버퍼 입출력</code>을 수행한다.<li>이는 커널이 아니라 <code class="language-plaintext highlighter-rouge">사용자 영역</code>에서 <code class="language-plaintext highlighter-rouge">버퍼링</code>을 처리한다는 의미<blockquote><p>커널은 내부적으로 <em>지연된 쓰기연산</em>, <em>미리읽기</em>, <em>연속된 입출력 요청</em> 을 모아서 처리하는 방식으로 버퍼링을 구현하고 있음.</p></blockquote></ul><p><img data-proofer-ignore data-src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/95217d8d-ef76-4652-99a1-e90de1942934/Untitled.png" alt="Untitled" /></p><p>일반 파일에 대해 잦은 입출력을 처리해야 하는 프로그램은 종종 사용자 버퍼 입출력을 수행한다.</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span text-data=" Shell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nb">dd </span><span class="nv">bs</span><span class="o">=</span>1 <span class="nv">count</span><span class="o">=</span>2097152 <span class="k">if</span><span class="o">=</span>/dev/zero <span class="nv">of</span><span class="o">=</span>pirate
</pre></table></code></div></div><p>2MB 데이터를 1B씩 약 2백만 번에 걸쳐 읽어들임</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span text-data=" Shell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nb">dd </span><span class="nv">bs</span><span class="o">=</span>1024 <span class="nv">count</span><span class="o">=</span>2048 <span class="k">if</span><span class="o">=</span>/dev/zero <span class="nv">of</span><span class="o">=</span>pirate
</pre></table></code></div></div><p>2MB 데이터를 1KB씩 약 2천 번에 걸쳐 읽어들임</p><div class="table-wrapper"><table><thead><tr><th>블록 크기 (Byte)<th>실제 시간 (초)<th>사용자 시간 (초)<th>시스템 시간 (초)<tbody><tr><td>1<td>18.707<td>1.118<td>17.549<tr><td>1024<td>0.025<td>0.002<td>0.023<tr><td>1130<td>0.035<td>0.002<td>0.027</table></div><p>1KB 단위로 읽어들이면 시스템콜의 횟수를 1024배 줄임으로써 성능을 비약적으로 개선할 수 있다.</p><p>다만 블록 크기를 1130 Byte로 키우면 시스템콜의 횟수는 줄지만 실제 물리 블록의 크기의 약수나 배수가 아니므로 성능 저하가 발생한다. 실제로 <code class="language-plaintext highlighter-rouge">/dev/zero</code>의 경우 블록 크기는 4096 Byte다.</p><h2 id="311-블록크기">3.1.1 블록크기</h2><ul><li>실제로 블록 크기는 보통 <em>512, 1024, 2048, 4096 혹은 8192</em>로 정해진다.<li>→ 커널과 하드웨어는 블록 크기를 기준으로 대화하기 때문에 블록 크기의 <strong>정수배</strong>나 <strong>약수 단위</strong>로 연산을 수행하기만 해도 상당한 성능 개선이 따라옴<li>그렇다면 모든 데이터를 <code class="language-plaintext highlighter-rouge">4KB</code> or <code class="language-plaintext highlighter-rouge">8KB</code>단위로 취급하는게 좋은가?<ul><li><strong>No</strong>. 실제로 데이터를 블록 단위로 취급하는 프로그램이 드물기에 <strong>현실성이 없음</strong></ul><li>프로그램은 블록 같은 추상 개념이 아니라 필드, 행, 단일 문자를 다룬다. 그래서 <code class="language-plaintext highlighter-rouge">사용자 버퍼 입출력</code>이 필요함.</ul><div class="language-bash highlighter-rouge"><div class="code-header"> <span text-data=" Shell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>데이터가 쓰여지면 프로그램 <span class="k">**</span>주소 공간 내 버퍼<span class="k">**</span>에 저장이 됨.
버퍼가 특정 크기에 도달하면 전체 버퍼는 <span class="k">**</span>한 번의 쓰기 연산을 통해 실제로 기록이 됨.<span class="k">**</span>

읽기 또한 버퍼 크기에 맞춰 <span class="k">**</span>블록에 정렬된 데이터를 읽는다.<span class="k">**</span>
</pre></table></code></div></div><p>→ 데이터가 많더라도 모두 블록 크기에 맞춰 <strong>적은 횟수의 시스템 콜만 사용하게 됨</strong>. 성능 향상!</p><blockquote><p>사용자 애플리케이션 코드 레벨에서 인위적으로 버퍼링을 구현해서 사용해야함.</p></blockquote><p>But, 표준 입출력 라이브러라 (stdio)와 표준 C++ iostream이라는 견고하고 뛰어난 사용자 버퍼링 구현체를 가져다 사용하면 된다!</p><blockquote></blockquote><h1 id="32-표준-입출력">3.2 표준 입출력</h1><ul><li>표준 C 라이브러리는 표준 입출력 라이브러리 (<code class="language-plaintext highlighter-rouge">stdio</code>)를 제공함</ul><h2 id="321-파일-포인터">3.2.1 파일 포인터</h2><ul><li>표준 입출력 루틴은 <strong>File Descriptor를 직접 다루지 않고, File pointer라는 독자적인 식별자를 사용</strong>한다.<li>표준 입출력 용어로 열린 파일은 <code class="language-plaintext highlighter-rouge">Stream</code> 이라고 부르기도 함.<ul><li>Stream 은 읽기(<em>입력 스트림</em>), 쓰기 (<em>출력 스트림</em>), 또는 읽기/쓰기 (<em>입출력 스트림</em>) 모드로 열 수 있음 <img data-proofer-ignore data-src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0fb2a2c6-0dcc-447f-8ee2-86c00749d2e1/Untitled.png" alt="Untitled" /></ul></ul><h1 id="33-파일-열기">3.3 파일 열기</h1><ul><li>파일을 읽거나 쓰기 위해서 <code class="language-plaintext highlighter-rouge">fopen()</code>을 사용한다.<li><strong>(FILE은 stdio.h 에 정의된 FILE typedef)</strong></ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kt">FILE</span> <span class="o">*</span> <span class="n">fopen</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mode</span><span class="p">)</span>

<span class="c1">// EX</span>
<span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">;</span>

<span class="n">stream</span> <span class="o">=</span> <span class="n">fopen</span> <span class="p">(</span><span class="s">"/etc/manifest"</span><span class="p">,</span> <span class="s">"r"</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stream</span><span class="p">)</span>
	<span class="n">ERROR</span>
</pre></table></code></div></div><ul><li>파일 path를 mode에 따라 원하는 용도로 새로운 스트림을 만든다.<li>성공 시 유효한 FILE 포인터를 반환.<li>실패 시 NULL 반환, errno 설정</ul><h2 id="331-모드">3.3.1 모드</h2><ul><li><strong><code class="language-plaintext highlighter-rouge">r</code></strong> : 읽기 목적으로 파일을 엶.<li><code class="language-plaintext highlighter-rouge">r+</code>: 읽기/쓰기 목적. 스트림은 파일 시작 지점.<li><strong><code class="language-plaintext highlighter-rouge">w</code></strong> : 쓰기 목적으로 파일을 엶. 파일이 이미 존재하면 길이를 0으로 잘라버림. 파일이 존재하지 않으면 새로 만듬.<li><code class="language-plaintext highlighter-rouge">w+</code>: 읽기/쓰기 목적. 파일이 이미 존재하면 길이를 0으로 자름. 파일이 존재하지 않으면 새로 만듦. 스트림은 파일 시작 지점.<li><strong><code class="language-plaintext highlighter-rouge">a</code></strong> : 덧붙이기 상태에서 쓰기 목적으로 파일을 엶.<li><code class="language-plaintext highlighter-rouge">a+</code>: 덧붙이기 상태에서 읽기/쓰기 목적으로 파일을 엶. 파일이 존재하지 않으면 새로 만듦. 스트림은 파일 끝 지점.</ul><h1 id="34-파일-디스크립터로-스트림-열기">3.4 파일 디스크립터로 스트림 열기</h1><ul><li><code class="language-plaintext highlighter-rouge">fdopen()</code> 함수는 이미 열린 파일 디스크립터를 통해 스트림을 만든다.</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">FILE</span> <span class="o">*</span> <span class="nf">fdopen</span> <span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mode</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>사용가능한 <code class="language-plaintext highlighter-rouge">mode</code>는 fopen()과 동일하며, 원래 fd를 열 때 사용했던 모드와 호환성을 유지해야 한다.<ul><li>fopen()에서는 w모드로 스트림을 열었을 때 이미 존재한다면 파일을 0으로 잘라버렸음. 하지만 fdopen()은 그렇지 않은데 그 이유는 <strong>이미 파일이 fd에 대해서 열려있기 때문</strong>.<li>따라서 open() 함수에 의해 반환 받은 fd를 fdopen() 함수에서 받았을 경우 open() 함수에 <code class="language-plaintext highlighter-rouge">O_TRUNC</code> 플래그가 있어야만 파일을 자를 수 있음!</ul><li>fd가 스트림으로 변환되면 그 fd를 통해 직접 입출력을 수행이 가능하긴 하지만 그렇게 하면 안됨!</ul><h1 id="35-스트림-닫기">3.5 스트림 닫기</h1><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">fclose</span> <span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">)</span>
</pre></table></code></div></div><ul><li>버퍼에 쌓여있지만 아직 스트림에 쓰지 않은 데이터를 먼저 처리함.<li>fclose 하면 fd까지 닫히나?<li>성공하면 0 반환, 실패하면 EOF 반환하고 errno 적절한 값으로 설정</ul><h2 id="351-모든-스트림-닫기">3.5.1 모든 스트림 닫기</h2><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">fcloseall</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">fcloseall()</code> 함수는 stdin, sdtout, stderr 를 포함해서 <strong>현재 프로세스와 관련된 모든 스트림을 닫는다</strong>.<li>닫기 전에 버퍼에 남아 있는 데이터는 모두 스트림에 쓰여지며 언제나 0을 반환</ul><h1 id="36-스트림에서-읽기">3.6 스트림에서 읽기</h1><ul><li>스트림에서 데이터를 읽으려면 w나 a를 제외한 나머지 모드(<code class="language-plaintext highlighter-rouge">읽기 가능 모드</code>)로 스트림을 열어야 함</ul><h2 id="361-한-번에-한-문자씩-읽기">3.6.1 한 번에 한 문자씩 읽기</h2><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">fgetc</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">)</span>
</pre></table></code></div></div><ul><li>stream 에서 다음 문자를 읽고 unsigned char 타입을 int 타입으로 변환해서 반환한다.<ul><li>타입 변환 이유 : 파일 끝이나 에러를 알려줄 수 있도록 하기 위함. 이런 에러일 때는 <code class="language-plaintext highlighter-rouge">EOF</code>반환<li>반드시 반환 값이 <code class="language-plaintext highlighter-rouge">int</code> 타입이어야 한다. <code class="language-plaintext highlighter-rouge">char</code>타입으로 저장하게 되면 에러 확인이 불가능함!</ul></ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">c</span><span class="p">;</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">fgetc</span> <span class="p">(</span><span class="n">stream</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">EOF</span><span class="p">)</span>
	<span class="c1">// error</span>
<span class="k">else</span>
	<span class="n">printf</span><span class="p">()</span>
</pre></table></code></div></div><h3 id="읽은-문자-되돌리기">읽은 문자 되돌리기</h3><ul><li>스트림을 찔러보고 원하는 문자가 아닌 경우 되돌려버린다.<li>즉, 스트림에 문자를 다시 집어넣는 것임.</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">ungetc</span> <span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">)</span>
</pre></table></code></div></div><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="c1">// 여러번 호출 시 역순으로 출력. LIFO (Last In First Out)</span>
<span class="c1">// 파일에 직접 쓰여지는 것이 아니라 버퍼에 쓰여지게 됨</span>
<span class="c1">// 리눅스에서는 메모리가 허용하는 범위 내에서 무제한 되돌리기 허용</span>

<span class="n">ungetc</span><span class="p">(</span><span class="sc">'a'</span><span class="p">,</span> <span class="n">stream</span><span class="p">);</span>
<span class="n">ungetc</span><span class="p">(</span><span class="sc">'b'</span><span class="p">,</span> <span class="n">stream</span><span class="p">);</span>

<span class="n">ch</span> <span class="o">=</span> <span class="n">getc</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>  <span class="c1">// ch 에는 b 가 들어간다.</span>
<span class="n">ch</span> <span class="o">=</span> <span class="n">getc</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>  <span class="c1">//  ch 에는 a 가 들어간다.</span>
</pre></table></code></div></div><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="c1">// 중간에 파일 위치 표시자의 값이 0이 된다면 그 이후에 호출된 unget함수들은 모두 무시됨.</span>

<span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">"test.txt"</span><span class="p">,</span> <span class="s">"r"</span><span class="p">);</span>
<span class="n">getc</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>         <span class="c1">// 이 함수 호출 이후 위치 표시자의 값은 1</span>
<span class="n">ungetc</span><span class="p">(</span><span class="sc">'a'</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>  <span class="c1">// 이 함수 호출 이후 값은 0</span>
<span class="n">ungetc</span><span class="p">(</span><span class="sc">'b'</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>  <span class="c1">// 따라서 버퍼에 b 가 들어갈 수 없다.</span>

<span class="n">ch</span> <span class="o">=</span> <span class="n">getc</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>  <span class="c1">// ch 에는 a 가 들어간다.</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%c"</span><span class="p">,</span> <span class="n">ch</span><span class="p">);</span>
<span class="n">ch</span> <span class="o">=</span> <span class="n">getc</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>  <span class="c1">//  ch 에는 test.txt 의 두 번째 문자가 들어간다.</span>
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">ungetc()</code>를 호출하고 중간에 탐색함수를 호출했고, 읽기 요청은 아직 하지 않았을 경우 되돌린 문자를 다 버린다.<ul><li><strong>스레드는 버퍼를 공유하므로</strong> 단일 프로세스에서 여러 스레드가 동작하는 경우에도 동일한 현상 발생</ul></ul><h2 id="362-한-줄씩-읽기">3.6.2 한 줄씩 읽기</h2><ul><li><code class="language-plaintext highlighter-rouge">fgets()</code> 함수는 stream에서 문자열을 읽는다.</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">char</span> <span class="o">*</span><span class="n">fgets</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">)</span>
</pre></table></code></div></div><ul><li>stream에서 size보다 하나 적은 내용을 읽어서 결과를 str에 저장한다.<li>마지막 바이트를 읽고 난 다음, <strong>버퍼 마지막에 null 문자 (\0)을 저장한다</strong>.<li>EOF나 개행문자를 만나면 읽기 중단. 개행문자를 읽으면 str에 \n을 저장<ul><li>무조건 \0은 마지막에 넣음.<li>문자열은 마지막에 NUll로 끝남</ul><li>성공하면 str을 반환, 에러일 경우 <code class="language-plaintext highlighter-rouge">NULL</code> 반환</ul><h3 id="원하는-만큼-문자열-읽기">원하는 만큼 문자열 읽기</h3><ul><li>행 단위로 읽는 방법은 유용하지만 다른 구분자를 사용하고 싶을 때도 있음<li>fgetc 로 fgets와 동일한 로직을 구현할 수 있다</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">c</span><span class="p">;</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">str</span>
<span class="c1">// n-1 바이트를 읽어서 str에 저장</span>
<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">c</span> <span class="o">=</span> <span class="n">fgets</span> <span class="p">(</span><span class="n">stream</span><span class="p">))</span> <span class="o">!=</span> <span class="n">EOF</span><span class="p">)</span>
	<span class="o">*</span><span class="n">s</span><span class="o">++</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>

<span class="c1">// \0 을 추가</span>
<span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
</pre></table></code></div></div><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>
<span class="c1">// d를 \n으로 하면 fgets와 동일</span>
<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">c</span> <span class="o">=</span> <span class="n">fgec</span> <span class="p">(</span><span class="n">stream</span><span class="p">)</span> <span class="o">!=</span> <span class="n">EOF</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="o">++</span> <span class="o">=</span> <span class="n">c</span><span class="p">)</span> <span class="o">!=</span> <span class="n">d</span><span class="p">)</span>
	<span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">==</span><span class="n">d</span><span class="p">)</span>
	<span class="o">*--</span><span class="n">s</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
<span class="k">else</span>
	<span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
</pre></table></code></div></div><h2 id="363-바이너리-데이터-읽기">3.6.3 바이너리 데이터 읽기</h2><ul><li>개별 문자나 행을 읽는 기능만으로 부족할때 (<em>C 구조체 같은 복잡한 바이너리 데이터를 읽고 써야하는 경우</em>) <code class="language-plaintext highlighter-rouge">fread()</code>함수 사용</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">size_t</span> <span class="n">fread</span><span class="p">(</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nr</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">)</span>
</pre></table></code></div></div><ul><li>stream에서 각각 크기가 size 바이트인 엘리먼트를 nr개 읽어서 buf가 가리키는 버퍼에 저장한다.<li>읽어들인 <strong>엘리먼트 개수</strong>가 반환됨.<li>nr보다 적은 값을 반환하여 실패나 EOF를 반환<ul><li><code class="language-plaintext highlighter-rouge">ferror()</code> or <code class="language-plaintext highlighter-rouge">feof()</code>를 사용하지 않고서는 실패 or EOF를 알 수가 없음</ul><li>변수의 크기, 정렬, 채워넣기, 바이트 순서가 다르기 때문에 어떤 애플리케이션에서 기록한 바이너리 데이터를 다른 앱에서는 못 읽을 수도 있다.</ul><h3 id="정렬문제">정렬문제</h3><ul><li>모든 아키텍처는 <code class="language-plaintext highlighter-rouge">데이터 정렬 요구사항</code>을 가지고 있음.<li>프로세스는 바이트 크기 단위로 메모리를 읽고 쓰지 않고, 2,4,8,,, 바이트처럼 정해진 기본 단위로 메모리에 접근함. → 기본 단위의 정수배로 시작하는 주소에 접근해야함<li>따라서 C언어에서 변수는 반드시 정렬된 주소에 저장하고 접근해야함.<ul><li>예를 들어 32비트 정수는 4바이트 경계에 맞춰 정렬됨. → int는 4로 나누어 떨어지는 메모리 주소 공간에 저장된다.</ul><li>정렬되지 않은 데이터 접근에 대해서는 다양한 패널티가 존재한다.<ul><li>접근 가능 but 성능 저하<li>접근 허용 X, 하드웨어 예외로 처리<li>강제 정렬을 위해 하위 비트를 제거해버림</ul></ul><h1 id="37-스트림에-쓰기">3.7 스트림에 쓰기</h1><h2 id="371-한-번에-문자-하나만-기록하기">3.7.1 한 번에 문자 하나만 기록하기</h2><ul><li>fgetc()에 대응하는 쓰기 함수는 <code class="language-plaintext highlighter-rouge">fputc()</code>이다.</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">fputc</span><span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>c로 지정한 바이트를 (unsigned char로 변환한 후에) stream이 가리키는 스트림에 쓴다.<ul><li>문자 혹은 숫자가 아스키 코드표에 맞게 int값으로 들어감.</ul><li>성공 시 c 반환, 실패 시 EOF 반환하고 errno 설정</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span><span class="n">fputc</span> <span class="p">(</span><span class="sc">'p'</span><span class="p">,</span> <span class="n">stream</span><span class="p">)</span> <span class="o">==</span> <span class="n">EOF</span><span class="p">)</span>
</pre></table></code></div></div><h2 id="372-문자열-기록하기">3.7.2 문자열 기록하기</h2><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">fputs</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">)</span>
</pre></table></code></div></div><ul><li>str이 가리키는 NULL로 끝나는 문자열 전무를 stream이 가리키는 스트림에 기록한다.<li>성공하면 음수가 아닌 값 반환, 실패 시 EOF 반환</ul><h2 id="373-바이너리-데이터-기록하기">3.7.3 바이너리 데이터 기록하기</h2><ul><li>C 변수처럼 바이너리 데이터를 직접 저장하려면 표준 입출력에서 제공하는 <code class="language-plaintext highlighter-rouge">fwrite()</code>를 사용</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kt">size_t</span> <span class="nf">fwrite</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
							<span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
							<span class="kt">size_t</span> <span class="n">nr</span><span class="p">,</span>
							<span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>buf가 가리키는 데이터에서 size크기의 엘리먼트 nr개를 stream에 쓴다.</ul><h1 id="38-사용자-버퍼-입출력-예제-프로그램">3.8 사용자 버퍼 입출력 예제 프로그램</h1><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">FILE</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="o">*</span><span class="n">out</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">pirate</span> <span class="p">{</span>
    <span class="kt">char</span>    <span class="n">name</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
    <span class="kt">unsigned</span> <span class="kt">long</span>   <span class="n">booty</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>    <span class="n">beard_len</span><span class="p">;</span>
  <span class="p">}</span> <span class="n">p</span><span class="p">,</span> <span class="n">blackbeard</span> <span class="o">=</span> <span class="p">{</span><span class="s">"Edward Teach"</span><span class="p">,</span> <span class="mi">950</span><span class="p">,</span> <span class="mi">48</span><span class="p">};</span>

  <span class="n">out</span> <span class="o">=</span> <span class="n">fopen</span> <span class="p">(</span><span class="s">"data"</span><span class="p">,</span> <span class="s">"w"</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">out</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">perror</span><span class="p">(</span><span class="s">"fopen"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fwrite</span><span class="p">(</span><span class="o">&amp;</span><span class="n">blackbeard</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pirate</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">out</span><span class="p">)){</span>
    <span class="n">perror</span> <span class="p">(</span><span class="s">"fwrite"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">fclose</span><span class="p">(</span><span class="n">out</span><span class="p">)){</span>
    <span class="n">perror</span><span class="p">(</span><span class="s">"fclose"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">in</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">"data"</span><span class="p">,</span> <span class="s">"r"</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pirate</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">in</span><span class="p">)){</span>
    <span class="n">perror</span><span class="p">(</span><span class="s">"fread"</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><blockquote><p>변수 크기, 정렬 등에서 차이가 있기 때문에 <strong>특정 애플리케이션에서 쓴 바이너리 데이터를 다른 애플리케이션에서 읽지 못할 수도 있다</strong>.</p></blockquote><p>만약 <code class="language-plaintext highlighter-rouge">unsigned long</code> 타입의 크기가 바뀌거나 채워 넣는 값의 양이 달라진다면 정확한 데이터를 못쓸것. 아키텍처와 ABI가 동일한 경우에만 바이너리 데이터를 일관적으로 읽고 쓸 수 있음.</p><blockquote></blockquote><ul><li>ABI : Application Binary Interface</ul><h1 id="39-스트림-탐색하기">3.9 스트림 탐색하기</h1><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">fseek</span> <span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">whence</span><span class="p">)</span>
</pre></table></code></div></div><ul><li><strong>offset</strong>과 <strong>whence</strong>에 따라 stream에서 파일 위치를 조작한다.<li><code class="language-plaintext highlighter-rouge">whence</code><ul><li>SEEK_SET - 파일 위치를 offset값으로 설정<li>SEEK_CUR - 현재위치에서 offset만큼 더한 값으로 설정<li>SEEK_END - 파일 위치를 파일 끝에서 offset만큼 더한 값으로 설정</ul><li>성공하면 0 반환하고 EOF 지시자를 초기화하고 이전에 실행했던 ungetc()를 취소한다.<li>에러 발생하면 -1 반환하고 errno를 설정<ul><li>EBADF - 유효하지 않은 스트림<li>EINVAL - whence인자 잘못됨</ul><li><code class="language-plaintext highlighter-rouge">fsetpos</code>는 stream의 위치를 pos로 설정한다.</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">fsetpos</span> <span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span> <span class="kt">fpos_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
</pre></table></code></div></div><ul><li>이는 <strong>whence</strong>가 SEEK_SET인 fseek()와 동일하게 동작함.<li>C의 long 타입만으로는 스트림의 위치를 지정하기에 충분하지 않으므로 어떤 플랫폼에서는 이 함수가 스트림 위치를 특정한 값으로 설정할 수 있는 유일한 방법임.</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">rewind</span> <span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">)</span>

<span class="c1">// ==</span>

<span class="n">fseek</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SEEK_SET</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>스트림을 시작 위치로 되돌리며 fseek을 위와 같이 사용하는 것과 동일함.<li>하지만 fseek()와는 달리 <code class="language-plaintext highlighter-rouge">rewind()</code>는 오류 지시자를 초기화 한다.<li>rewind는 반환값이 없어서 에러 조건을 직접적으로 파악할 수가 없음.</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="c1">// 이런식으로 직접 확인을 해야함.</span>

<span class="n">errno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">rewind</span><span class="p">(</span><span class="n">stream</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">errno</span><span class="p">)</span>
	<span class="c1">//error</span>
</pre></table></code></div></div><h2 id="391-현재-스트림-위치-알아내기">3.9.1 현재 스트림 위치 알아내기</h2><ul><li>lseek()와는 다르게 fseek()는 갱신된 위치를 반환하지 않음.<li>따라서 위치를 파악하기 위한 용도로 분리된 인터페이스를 제공함.<li><code class="language-plaintext highlighter-rouge">ftell</code> 은 현재 스트림 위치를 반환한다.</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">long</span> <span class="nf">ftell</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>표준 입출력에서는 <code class="language-plaintext highlighter-rouge">fgetpos</code>도 제공을 한다.</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">fgetpos</span> <span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span> <span class="kt">fpos_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
</pre></table></code></div></div><ul><li>성공하면 0을 반환하고 현재 스트림 위치를 pos에 기록함.<li>실패하면 -1을 반환하고 errno를 설정<li>fsetpos()와 마찬가지로 fgetpos()는 복잡한 파일 위치 타입을 사용하는 비-유닉스 플랫폼을 위해 제공한다.</ul><h1 id="310-스트림-비우기">3.10 스트림 비우기</h1><ul><li>표준 입출력 라이브러리는 사용자 버퍼를 커널로 비워서 스트림에 쓴 모든 데이터가 write()을 통해 실제로 디스크에 기록되도록 만드는 인터페이스를 제공함.</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">fflush</span> <span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>stream에 있는 쓰지 않은 데이터를 커널로 비운다.<li>stream이 NULL이면 프로세스의 열려있는 모든 입력 스트림이 비워짐.<li>성공하면 0 반환, 실패하면 EOF반환하고 errno를 설정<li><code class="language-plaintext highlighter-rouge">fflush()</code>와 버퍼<ul><li>여기서 설명하는 모든 함수 호출은 <code class="language-plaintext highlighter-rouge">커널이 유지하는 버퍼</code>가 아니라 <strong><code class="language-plaintext highlighter-rouge">C 라이브러리가 관리하는 버퍼</code></strong> 를 의미한다. 이는 커널 영역이 아니라 사용자 영역에 위치함. → 시스템 콜을 사용하지 않고 사용자 코드를 실행함으로써 성능개선<li>fflush()는 단지 사용자 버퍼에 있는 데이터를 커널 버퍼로 쓰기만 함. → 이는 사용자 버퍼를 사용하지 않고 write()을 직접 사용하는 효과와 동일<li>즉, 데이터를 매체에 물리적으로 기록한다는 보장이 없다.<li>데이터가 매체에 즉각 기록되어야 하는 경우에는 fflush()를 호출한 다음 바로 fsync()를 호출한다. → 사용자 버퍼를 커널에 쓰고 fsync()를 통해 커널 버퍼를 디스크에 기록하도록 보장한다.</ul></ul><h1 id="311-에러와-eof">3.11 에러와 EOF</h1><ul><li><p>fread()와 같은 몇몇 표준 입출력 인터페이스는 에러와 EOF를 구분하는 방법을 제공하지 않는 등 이슈가 있다.</p><li><p><code class="language-plaintext highlighter-rouge">ferror()</code>는 스트림에 에러 지시자가 설정되었는지 검사한다.</p></ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">ferror</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">)</span>
</pre></table></code></div></div><ul><li>에러 지시자는 에러 조건에 따라 표준 입출력 인터페이스에서 설정한다.<li><p>해당 스트림에 에러 지시자가 설정되어 있을 경우 0이 아닌 값을 반환, 그렇지 않은 경우 0 반환</p><li><code class="language-plaintext highlighter-rouge">feof()</code>는 해당 스트림에 EOF 지시자가 설정되어 있는지 검사한다.</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">feof</span> <span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">)</span>
</pre></table></code></div></div><ul><li><p>EOF 지시자는 파일 끝에 도달하면 표준 입출력 인터페이스에서 설정한다.</p><li><p><code class="language-plaintext highlighter-rouge">clearerr()</code> 함수는 스트림에서 에러 지시자와 EOF 지시자를 초기화한다.</p></ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">clearerr</span> <span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>반환값이 없고 항상 성공하기 때문에 stream 인자값이 정상인지 확인할 수 있는 방법이 없다.<li>이를 호출하고 나면 다시 복구할 방법이 없으므로 <code class="language-plaintext highlighter-rouge">에러 지시자</code>와 <code class="language-plaintext highlighter-rouge">EOF 지시자</code>를 먼저 검사한 후에 호출해야함</ul><h1 id="312-파일-디스크립터-얻어오기">3.12 파일 디스크립터 얻어오기</h1><ul><li>스트림에서 파일 디스크립터를 구해야 하는 경우가 있다.<ul><li>대응하는 표준 입출력 함수가 없을 때</ul></ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">fileno</span> <span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">)</span>
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">fileno</code>를 통해서 <strong>fd</strong>를 구할 수 있다.<li>성공하면 stream과 관련된 fd를 반환하고, 실패하면 -1을 반환.<ul><li>주어진 스트림이 유효하지 않은 경우 errno를 EBADF로 설정</ul></ul><blockquote><p>표준 입출력 함수와 시스템 콜 사이에서 사용자 버퍼링과 관련된 충돌이 발생하지 않도록 주의해야 함 fd를 사용하기전에 스트림을 비우는 것은 좋은 습관. <strong>어쨌든 두가지를 섞어 쓰는 것은 좋지 않다.</strong></p></blockquote><h1 id="313-버퍼링-제어하기">3.13 버퍼링 제어하기</h1><ul><li>표준 입출력은 세 가지 유형의 사용자 버퍼링을 구현하고, 버퍼의 유형과 크기를 다룰 수 있는 인터페이스를 제공한다.<li>각각의 사용자 버퍼링 타입은 저마다의 목적이 있으며 상황에 맞게 사용할 때 가장 이상적임</ul><h3 id="버퍼-미사용">버퍼 미사용</h3><ul><li>사용자 버퍼를 사용하지 않는다.<li>즉, 커널로 바로 데이터를 보낸다. 표준 에러를 제외하고는 거의 사용되지 않음</ul><h3 id="행-버퍼">행 버퍼</h3><ul><li>행 단위로 버퍼링을 수행한다.<li>즉, 개행문자가 나타나면 버퍼의 내용을 커널로 보난다.<li>화면 출력 메시지는 개행문자로 구분되기 때문에 행 버퍼는 화면 출력을 위한 스트림일 경우 유용함.<li>표준 출력처럼 터미널에 연결된 스트림에서 기본적으로 사용</ul><h3 id="블록-버퍼">블록 버퍼</h3><ul><li>고정된 바이트 개수로 표현되는 블록 단위로 버퍼링을 수행한다.<li>기본적으로 파일과 관련된 모든 스트림은 블록 버퍼를 사용한다.<li><p>표준 입출력에서는 블록 버퍼링을 Full 버퍼링이라고 한다.</p><li>표준 입출력은 버퍼링 방식을 제어할 수 있는 인터페이스를 제공한다.</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">setvbuf</span> <span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">mode</code><ul><li>_IONBF - 버퍼 미사용<li>_IOLBF - 행 버퍼<li>_IOFBF - 블록 버퍼</ul><li>buf 와 size를 무시하는 _IONBF를 제외하고 나머지는 size 바이트 크기의 버퍼를 가리키는 buf를 주어진 stream을 위한 버퍼로 사용한다.<ul><li>buf가 NULL이라면 glibc 가 자동적으로 지정된 크기만큼 메모리를 할당한다.</ul><li>스트림을 연 다음 다른 연산을 수행하기 전에 호출해야함.<li>제공된 버퍼는 스트림이 닫힐 때까지 반드시 존재해야 한다.<ul><li>흔히 스트림을 닫기 전에 끝나는 스코프 내부의 자동 변수로 버퍼를 선언하는 실수를 함.<li>특히 main()에서 지역변수로 버퍼를 만든 다음에 스트림을 명시적으로 닫지 않는 경우를 주의해야함.<div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
  <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">BUFSIZ</span><span class="p">];</span>

  <span class="c1">// stdout을 bufsiz 크기에 맞춰 블록 버퍼로 설정한다.</span>
  <span class="n">setvbuf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">_IOFBF</span><span class="p">,</span> <span class="n">BUFSIZ</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">// buf는 스코프를 벗어나고 해제된다. 하지만 stdout을 닫지 않았음</span>
<span class="p">}</span>
</pre></table></code></div></div><li>스코프를 벗어나기 전에 스트림을 명시적으로 닫아주거나, buf를 전역 변수로 설정함으로써 방지할 수 있음.</ul></ul><blockquote><p>표준 에러를 제외하고 터미널은 행 버퍼링으로 동작, 파일은 블록 버퍼링을 사용하는 것이 맞다. 블록 버퍼링에서 버퍼의 기본 크기는 BUFSIZ이며 일반적인 블록 크기의 정수배인 최적의 값이다.</p></blockquote><p>따라서 개발자들은 일반적으로 스트림을 다룰 때 버퍼링에 대해 고민할 필요가 없다.</p><blockquote></blockquote><h1 id="314-스레드-세이프">3.14 스레드 세이프</h1><blockquote><p><strong><code class="language-plaintext highlighter-rouge">스레드</code></strong> : 개별 프로세스 내에 존재하는 여러 개의 실행 단위. <strong>멀티 스레드 프로세스</strong> : 주소 공간을 공유하는 여러 개의 프로세스</p></blockquote><blockquote><p><strong><code class="language-plaintext highlighter-rouge">스레드 세이프</code>(Thread-safe)</strong> 멀티 스레드 프로그래밍에서 일반적으로 어떤 함수나 변수, 혹은 객체가 여러 스레드로부터 동시에 접근이 이루어져도 프로그램의 실행에 문제가 없음을 뜻함</p></blockquote><p>→ 멀티스레드 환경에서 동작해도 원래 의도한 대로 동작하는 것을 <code class="language-plaintext highlighter-rouge">스레드 세이프</code> 하다고 할 수 있음</p><ul><li><p>Thread Safe 하지 않은 코드 예시</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span text-data=" Shell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre>int num<span class="p">;</span>
boolean is_even<span class="p">;</span>

int inc<span class="o">(</span>int n<span class="o">)</span>
<span class="o">{</span>
	num +<span class="o">=</span> n<span class="p">;</span>
	<span class="k">if</span> <span class="o">((</span>num%2<span class="o">)</span> <span class="o">==</span> 0<span class="o">)</span>
		is_even <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">else
		</span>is_evne <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">return </span>num<span class="p">;</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>num이라는 변수에 숫자를 더해서 짝수이면 is_even = true, 홀수이면 false로 설정<li>싱글 스레드 환경에서는 문제없는 코드</ul><div class="language-bash highlighter-rouge"><div class="code-header"> <span text-data=" Shell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>a <span class="o">=</span> int<span class="o">(</span>1<span class="o">)</span><span class="p">;</span>
</pre></table></code></div></div><ul><li>위의 라인을 멀티스레드에서 수행했을 경우 의도와 맞지 않는 결과가 발생할 수 있음</ul><li><strong>멀티코어 시스템</strong>에서는 둘 이상의 스레드가 같은 프로세스에서 동시에 실행될 수가 있다.<ul><li>스레드에서 데이터에 접근할 때 <code class="language-plaintext highlighter-rouge">동기화에 주의</code>하지 않거나, <code class="language-plaintext highlighter-rouge">스레드 로컬</code>(스레드 감금) 로 만들지 않으면 스레드가 공유 데이터를 덮어써버릴 수 있다.</ul><li>스레드를 지원하는 OS는 락 메커니즘을 지원한다. 표준 입출력은 이런 메커니즘을 활용해서 단일 프로세스 내의 여러 스레드가 동시에 표준 입출력을 호출할 수 있도록 한다. <em>심지어는 같은 스트림에 대해서도 가능하다.</em><li><strong>하지만 이것만으로는 부족함</strong><ol><li>여러 함수 호출을 그룹으로 묶어 통째로 락을 걸면 <strong>크리티컬 섹션</strong>이 하나의 입출력 연산에서 여러 입출력 연산으로 확장됨<ul><li>크리티컬 섹션 : 임계 구역. 다른 스레드의 간섭 없이 실행할 수 있는 코드</ul><li>효율성을 높이기 위해 락을 완전히 없애고 싶은 경우<ul><li>락을 없애면 온갖 문제가 난무하지만 어떤 프로그램은 모든 입출력을 싱글 스레드에 위임하여 스레드를 가두어서 스레드 세이프를 구현하기도 함. → 락에 의한 오버헤드가 없다.</ul></ol><li>스레드는 입출력 요청에 앞서 락을 획득하고 고유 스레드가 되어야 함<ul><li>표준 입출력 함수는 본질적으로 스레드 세이프를 보장한다는 것<li>단일 함수 호출 관점에서 보면 표준 입출력 연산은 Atomic 하다.</ul></ul><h2 id="3141-수동으로-파일-락-걸기">3.14.1 수동으로 파일 락 걸기</h2><ul><li>stream의 락이 해제될 때까지 기다린 후에 락 카운터를 올리고 락을 얻은 다음, 스레드가 stream을 소유하도록 만든 후에 반환한다.</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">flockfile</span> <span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">);</span>
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">funlockfile</code> 함수는 stream과 연관된 락 카운터를 하나 줄인다.</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">funlockfile</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>락 카운터가 0이 되면 현재 스레드는 stream의 소유권을 포기해서 다른 스레드가 락을 얻을 수 있도록 한다.<li><p>여러번 중첩 호출이 가능함.</p><li><code class="language-plaintext highlighter-rouge">ftrylockfile()</code> 함수는 flockfile()의 <strong>논블록 버전</strong>이다.</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">ftrylockfile</span> <span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">)</span>
</pre></table></code></div></div><ul><li>stream이 락이 걸려있다면 <code class="language-plaintext highlighter-rouge">ftrylockfile()</code>은 아무것도 하지 않고 즉시 0이 아닌 값을 반환함.<li>논블록이 아니라면, 락이 걸린 상태에서는 블록되어서 계속 기다려야함.<li>만약 stream이 락이 걸린 상태가 아니라면 락을 걸고 락 카운터를 하나 올린 다음 그 stream을 소유하도록 만들고 0을 반환한다.</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">flockfile</span> <span class="p">(</span><span class="n">stream</span><span class="p">);</span>

<span class="n">fputs</span><span class="p">(</span><span class="s">"a"</span><span class="p">,</span> <span class="n">stream</span><span class="p">);</span>
<span class="n">fputs</span><span class="p">(</span><span class="s">"b"</span><span class="p">,</span> <span class="n">stream</span><span class="p">);</span>
<span class="n">fputs</span><span class="p">(</span><span class="s">"c"</span><span class="p">,</span> <span class="n">stream</span><span class="p">);</span>

<span class="n">funlockfile</span><span class="p">(</span><span class="n">stream</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>기록 중 다른 스레드가 중간에 끼어들지 못하게 하려면 락을 이용해야함.<li>설계 자체에서 동일 스트림을 대상으로 입출력하지 않도록 해야한다.<li>만약 그렇게 할 수 없다면 flockfile() 같은 함수를 이용해서 크리티컬 섹션을 확장해야 함.</ul><h2 id="3142-락을-사용하지-않는-스트림-연산">3.14.2 락을 사용하지 않는 스트림 연산</h2><ul><li>상세하고 정밀한 락 제어를 통해 가능한 한 락 오버헤드를 최소화해서 성능을 향상시킬 수 있기때문에 스트림에 대해 수동으로 락을 설정함.<li>앞서 다루었던 표준 입출력 함수들은 내부적으로 락을 사용한다.<li>수동으로 락을 걸면 각 표준 입출력 함수들의 내부적인 락을 사용하지 않아도 된다.<li><code class="language-plaintext highlighter-rouge">_unlocked</code> postfix가 붙은 함수들을 이용하면 락 오버헤드를 최소화할 수 있다.</ul><h1 id="315-표준-입출력-비평">3.15 표준 입출력 비평</h1><ul><li>몇몇 전문가는 표준 입출력의 결함을 지적함<ul><li>fgets()는 충분한 기능을 제공하지 못한다<ul><li>wild character 같은 경우 eof 로 읽을 수도 있음</ul><li>gets()는 표준에서 제거되기도 함..<div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="err">경고</span><span class="o">:</span> <span class="n">the</span> <span class="err">‘</span><span class="n">gets</span><span class="err">‘</span> <span class="n">function</span> <span class="n">is</span> <span class="n">dangerous</span> <span class="n">and</span> <span class="n">should</span> <span class="n">not</span> <span class="n">be</span> <span class="n">used</span><span class="p">.</span>
</pre></table></code></div></div><blockquote><p>이 문제는 gets함수가 strName[20]의 크기를 모르면서 개행을 찾거나 EOF를 만날 때까지 계속 읽기 때문에 주어진 버퍼의 크기를 넘을 수 있습니다. 다르게 설명하자면 C언어는 경계 검사를 수행하지 않아 gets함수가 접근 권한이 없는 주소에 도달 할 때까지 읽기를 계속합니다. 접근 권한이 없는 주소에 도달하는 이런 행위가 아마도 Linux에서는 시스템을 이상 종료 시킬 수 있는 오류 일 것입니다. 그래서 많은 바이러스가 이러한 문제점을 이용합니다.</p></blockquote></ul><li>가장 큰 불만은 <code class="language-plaintext highlighter-rouge">이중 복사로 인한 성능 문제</code>이다.<ul><li>데이터를 읽을 때 표준 입출력의 read() 시스템 콜을 사용하면 데이터는 커널에서 표준 입출력의 버퍼로 복사된다.<li>fgetc()같은 표준 입출력을 통해서 읽기를 요청하면 그 데이터는 표준 입출력 버퍼에서 인자로 제공된 버퍼로 또 복사된다.<li>쓰기 요청도 마찬가지</ul><li>읽기 요청은 표준 입출력 버퍼를 가리키는 포인터를 반환하는 대체 구현으로 이중 복사 문제를 피할 수 있음<li>쓰기 요청도 포인터 기록을 통해서 피할 수 있음</ul><h1 id="316-맺음말">3.16 맺음말</h1><ul><li>표준 입출력은 표준 C 라이브러리의 일부로 제공되는 사용자 버퍼링 라이브러리이다.<li>아래의 가정을 만족할 때 표준 입출력과 사용자 버퍼링은 의미가 있다.<ol><li><em>많은 시스템 콜이 의심되는 경우 수 많은 호출을 합쳐서 줄이는 방법으로 오버헤드를 줄이고 싶다.</em><li><em>성능이 중요하며 모든 입출력은 정렬된 블록 경계에 맞춰 블록 크기 단위로 일어나도록 확실하게 보장해야 한다.</em><li><em>접근 패턴이 문자나 행 기반이며 낯선 시스템 콜에 의지하지 않고 손쉽게 데이터에 접근할 수 있는 인터페이스가 필요하다.</em><li><em>저수준 리눅스 시스템 콜보다는 고수준의 인터페이스를 선호한다.</em></ol></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/linux/'>Linux</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/blog/" class="post-tag no-text-decoration" >blog</a> <a href="/tags/jekyll/" class="post-tag no-text-decoration" >jekyll</a> <a href="/tags/jekyll-theme/" class="post-tag no-text-decoration" >jekyll theme</a> <a href="/tags/next-theme/" class="post-tag no-text-decoration" >NexT theme</a> <a href="/tags/computer-science/" class="post-tag no-text-decoration" >Computer Science</a> <a href="/tags/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B3%B5%ED%95%99/" class="post-tag no-text-decoration" >컴퓨터공학</a> <a href="/tags/%EA%B0%9C%EB%B0%9C/" class="post-tag no-text-decoration" >개발</a> <a href="/tags/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4/" class="post-tag no-text-decoration" >소프트웨어</a> <a href="/tags/%EC%A7%80%ED%82%AC-%ED%85%8C%EB%A7%88/" class="post-tag no-text-decoration" >지킬 테마</a> <a href="/tags/%EC%A7%80%ED%82%AC-%EB%B8%94%EB%A1%9C%EA%B7%B8-%ED%8F%AC%EC%8A%A4%ED%8C%85/" class="post-tag no-text-decoration" >지킬 블로그 포스팅</a> <a href="/tags/github-pages/" class="post-tag no-text-decoration" >GitHub Pages</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=[Linux System Programming] Ch03 버퍼 입출력 - Hans H. Kim&url=https://hhhyunwoo.github.io//posts/linux_ch03/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=[Linux System Programming] Ch03 버퍼 입출력 - Hans H. Kim&u=https://hhhyunwoo.github.io//posts/linux_ch03/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=[Linux System Programming] Ch03 버퍼 입출력 - Hans H. Kim&url=https://hhhyunwoo.github.io//posts/linux_ch03/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/blog-newjourney/">🏢 첫번째 퇴사, 첫번째 이직</a><li><a href="/posts/k8s-nginx-413-error/">[K8S] Ingress Nginx 413 http error (payload too large) 이슈 해결</a><li><a href="/posts/infiniband-nccl-issue/">[Infiniband] NCCL WARN Call to ibv_reg_mr failed 이슈 해결</a><li><a href="/posts/k8s_service/">[Kubernetes] Kubernetes 서비스 정리(ClusterIP, Nodeport, Loadbalancer) </a><li><a href="/posts/k8s-kernel-epoll-etcd-leader/">[K8S] 5.4.0-132 커널의 epoll 버그로 인한 etcd leader election 이슈</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/blog/">blog</a> <a class="post-tag" href="/tags/github-pages/">GitHub Pages</a> <a class="post-tag" href="/tags/jekyll-theme/">jekyll theme</a> <a class="post-tag" href="/tags/jekyll/">jekyll</a> <a class="post-tag" href="/tags/next-theme/">NexT theme</a> <a class="post-tag" href="/tags/%EC%A7%80%ED%82%AC-%EB%B8%94%EB%A1%9C%EA%B7%B8-%ED%8F%AC%EC%8A%A4%ED%8C%85/">지킬 블로그 포스팅</a> <a class="post-tag" href="/tags/%EC%A7%80%ED%82%AC-%ED%85%8C%EB%A7%88/">지킬 테마</a> <a class="post-tag" href="/tags/computer-science/">Computer Science</a> <a class="post-tag" href="/tags/%EA%B0%9C%EB%B0%9C/">개발</a> <a class="post-tag" href="/tags/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4/">소프트웨어</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/docker/"><div class="card-body"> <span class="timeago small" >Feb 7, 2022<i class="unloaded">2022-02-07T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Docker] Centos Image 에서 sudo command not found 에러</h3><div class="text-muted small"><p> Centos Image 에서 sudo command not found centos/python-36-centos7 이미지 사용 도중 Dockerfile 내부에서 커맨드로 파일의 모드를 바꿔야할 일이 생겼다. RUN sudo chmod 755 start.sh 근데 sudo 를 실행했을 떄 /bin/sh: sudo: command not fo...</p></div></div></a></div><div class="card"> <a href="/posts/First-post/"><div class="card-body"> <span class="timeago small" >Nov 12, 2021<i class="unloaded">2021-11-12T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>First Post</h3><div class="text-muted small"><p> Welcome Hello world, this is my first Jekyll blog post. I hope you like it!</p></div></div></a></div><div class="card"> <a href="/posts/tb07-jekyll-bundler-error/"><div class="card-body"> <span class="timeago small" >Nov 13, 2021<i class="unloaded">2021-11-13T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Trouble Shooting] Jekyll chirpy 템플릿으로 Github 블로그 시작하기. (Bundler Install Error)</h3><div class="text-muted small"><p> Jekyll chirpy 템플릿으로 Github 블로그 시작하기. (Bundler Install Error) Github 블로그 with Chirpy Jekyll Theme github 블로그를 시작할 때 Jekyll을 많이 사용한다. 그럼 Jekyll이 무엇일까? Jekyll? 텍스트 변환 엔진으로, Markup 언어로 글을 작성하면 이...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/linux_ch02/" class="btn btn-outline-primary" prompt="Older"><p>[Linux System Programming] Ch02 파일 입출력</p></a> <a href="/posts/linux_ch04/" class="btn btn-outline-primary" prompt="Newer"><p>[Linux System Programming] Ch04 고급 버퍼 입출력</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://github.com/hhhyunwoo">Hans H. Kim</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/blog/">blog</a> <a class="post-tag" href="/tags/github-pages/">GitHub Pages</a> <a class="post-tag" href="/tags/jekyll-theme/">jekyll theme</a> <a class="post-tag" href="/tags/jekyll/">jekyll</a> <a class="post-tag" href="/tags/next-theme/">NexT theme</a> <a class="post-tag" href="/tags/%EC%A7%80%ED%82%AC-%EB%B8%94%EB%A1%9C%EA%B7%B8-%ED%8F%AC%EC%8A%A4%ED%8C%85/">지킬 블로그 포스팅</a> <a class="post-tag" href="/tags/%EC%A7%80%ED%82%AC-%ED%85%8C%EB%A7%88/">지킬 테마</a> <a class="post-tag" href="/tags/computer-science/">Computer Science</a> <a class="post-tag" href="/tags/%EA%B0%9C%EB%B0%9C/">개발</a> <a class="post-tag" href="/tags/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4/">소프트웨어</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-EPY53PE167"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-EPY53PE167'); }); </script>
