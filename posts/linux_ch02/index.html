<!DOCTYPE html><html lang="en" mode="light" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="[Linux System Programming] Ch02 파일 입출력" /><meta property="og:locale" content="en" /><meta name="description" content="Ch02 파일 입출력" /><meta property="og:description" content="Ch02 파일 입출력" /><link rel="canonical" href="https://hhhyunwoo.github.io//posts/linux_ch02/" /><meta property="og:url" content="https://hhhyunwoo.github.io//posts/linux_ch02/" /><meta property="og:site_name" content="Hans H. Kim" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-03-09T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[Linux System Programming] Ch02 파일 입출력" /><meta name="twitter:site" content="@twitter_username" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-07-10T15:41:43+09:00","datePublished":"2022-03-09T00:00:00+09:00","description":"Ch02 파일 입출력","headline":"[Linux System Programming] Ch02 파일 입출력","mainEntityOfPage":{"@type":"WebPage","@id":"https://hhhyunwoo.github.io//posts/linux_ch02/"},"url":"https://hhhyunwoo.github.io//posts/linux_ch02/"}</script><title>[Linux System Programming] Ch02 파일 입출력 | Hans H. Kim</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Hans H. Kim"><meta name="application-name" content="Hans H. Kim"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/newyork_hw.jpeg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Hans H. Kim</a></div><div class="site-subtitle font-italic">Machine Learning Engineer <br> <br> Keep Blizt and Be Simple</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/all-posts/" class="nav-link"> <i class="fa-fw fas fa-blog ml-xl-3 mr-xl-3 unloaded"></i> <span>POSTS</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/hhhyunwoo" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['hyunwoo.h.kim','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>[Linux System Programming] Ch02 파일 입출력</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>[Linux System Programming] Ch02 파일 입출력</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Hans H. Kim </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Mar 9, 2022, 12:00 AM +0900" >Mar 9, 2022<i class="unloaded">2022-03-09T00:00:00+09:00</i> </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Sun, Jul 10, 2022, 3:41 PM +0900" >Jul 10, 2022<i class="unloaded">2022-07-10T15:41:43+09:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="8295 words">46 min read</span></div></div><div class="post-content"><h1 id="ch02-파일-입출력">Ch02 파일 입출력</h1><h1 id="2-파일-입출력">2. 파일 입출력</h1><p>리눅스는 많은 인터페이스를 <code class="language-plaintext highlighter-rouge">파일</code>로 구현했음. (유닉스 시스템에서는 거의 모든 것을 파일로 표현)</p><p><strong>파일 입출력은 단순한 파일 처리를 넘어서 다양한 작업에 밀접하게 관련되어 있음.</strong></p><p>파일은 읽거나 쓰기 전에 반드시 열어야 한다.</p><ul><li><strong>File Table</strong><ul><li>커널은 파일 테이블이라고 하는 프로세스 별로 열린 파일 목록을 관리 함.<li>File Descripter(<code class="language-plaintext highlighter-rouge">fd</code>)<ul><li>음이 아닌 정수 값으로 인덱싱 되어있음</ul><li>각 항목은 열린 파일에 대한 정보를 담고 있음<ul><li>inode Pointer<li>Metadata</ul></ul><li><strong>fd</strong><ul><li>0 : stdin<li>1 : stdout<li>2 : stderr<li>읽고 쓸 수 있는 모든 것은 파일 디스크립터를 통해 접근할 수 있음 <img data-proofer-ignore data-src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1bd7c945-9cbd-4e54-8bd8-2846e0f3f0c3/Untitled.png" alt="Untitled" /></ul></ul><h2 id="21-파일-열기">2.1 파일 열기</h2><ul><li>파일 접근하는 기본적인 방법<ul><li><code class="language-plaintext highlighter-rouge">read()</code>, <code class="language-plaintext highlighter-rouge">write()</code><li>하지만 접근하기 전에 <code class="language-plaintext highlighter-rouge">open()</code> 이나 <code class="language-plaintext highlighter-rouge">creat()</code> 로 열고, 다 쓴 후에는 <code class="language-plaintext highlighter-rouge">close()</code>로 닫아야함.</ul></ul><h3 id="open-시스템-콜">open() 시스템 콜</h3><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">open</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">open</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="n">mode_t</span> <span class="n">mode</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>경로 이름이 name인 파일을 fd에 맵핑<ul><li>성공하면 fd return</ul><li>offset 0으로 설정<ul><li>실패 시 -1 리턴</ul><li>flags<ul><li>O_RDONLY, O_WRONLY, O_RDWR<li>이외에도 여러가지 플래그들이 있는데, flags 파라미터에 OR연산을 통해 작동 가능<ul><li><div class="table-wrapper"><table><tbody><tr><td>O_WRONLY<td>O_TRUNC</table></div></ul></ul></ul><h3 id="새로운-파일의-권한">새로운 파일의 권한</h3><p>파일 생성하는게 아니라면 open()의 mode 인자는 무시됨.</p><p>하지만 O_CREAT과 같이 생성 시에는 mode가 꼭 필요하다.</p><h3 id="creat-함수">creat() 함수</h3><div class="table-wrapper"><table><tbody><tr><td>O_WRONLY<td>O_CREAT<td>O_TRUNC</table></div><p>→ <em>읽기 전용, 해당 파일이 없으면 새로 생성, 파일이 존재하고 일반파일이며 flags인자에 쓰기가 가능하다면 파일 길이를 0으로 잘라버림</em></p><p>→ 너무나도 일반적인 flags라서 이를 지원하는 시스템 콜이 바로 <code class="language-plaintext highlighter-rouge">create()</code></p><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">fd</span> <span class="o">=</span> <span class="n">creat</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>

<span class="o">==</span>

<span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">O_WRONLY</span> <span class="o">|</span> <span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_TRUNC</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>
</pre></table></code></div></div><h2 id="22-read로-읽기">2.2 read()로 읽기</h2><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">ssize_t</span> <span class="nf">read</span> <span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>
</pre></table></code></div></div><p>호출할 때마다 fd가 참조하는 파일의 현재 오프셋에서 len 바이트만큼 buf로 읽어 들인다.</p><ul><li>return<ul><li>성공 시 buf에 쓴 바이트 숫자<li>실패 시 -1</ul></ul><h3 id="read의-여러가지-반환-케이스">read()의 여러가지 반환 케이스</h3><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">nr</span> <span class="o">=</span> <span class="n">read</span> <span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">word</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span>
</pre></table></code></div></div><ul><li><strong>nr == len 같은 값</strong> : 정상<li><strong>0 &lt; nr &lt; len</strong> : 읽은 바이트는 word에 저장.<ul><li>중간에 시그널이 중단 or 읽는 도중 에러 발생 or len 만큼 읽기전에 EOF 발생<li>→ 원인 파악 가능 (buf ,len 을 고친다음 호출 수행)</ul><li><strong>nr == 0</strong> : EOF<li><strong>블록</strong> : 현재 사용가능한 데이터가 없음<li><strong>nr == -1 &amp;&amp; EINTR</strong> : 바이트 읽기 전에 시그널 도착<li><strong>nr == -1 &amp;&amp; EAGAIN</strong> : 읽을 데이터가 없어서 블록. 논믈록 모드 일 때만 일어나는 상황<li><strong>nr == -1 &amp;&amp; OTHER</strong> : 심각한 에러</ul><p>→ 일반적인 read()는 에러 처리하면서 실제로 모든 len 바이트( 적어도 EOF까지)를 읽는 경우 적합하지 않음</p><div class="language-python highlighter-rouge"><div class="code-header"> <span text-data=" Python "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">while</span> <span class="p">(</span><span class="nb">len</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ret</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="nb">len</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EINTR</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">perror</span> <span class="p">(</span><span class="s">"read"</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="nb">len</span> <span class="o">-=</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">buf</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>위의 코드는 5가저 조건을 모두 처리한다.</p><h3 id="논블록-읽기"><strong>논블록</strong> 읽기</h3><ul><li>때떄로 프로그래머 입장에서 읽을 데이터가 없을 때 read()호출이 블록되지 않기를 바라는 경우가 있음<li>블록되는 대신 읽을 데이터가 없다는 사실을 알려주기 위해 호출이 즉시 반환되는 편을 선호한다.<li>open() 할 때 플래그를 <code class="language-plaintext highlighter-rouge">O_NONBLOCK</code>을 넘겨주었다면 파일 디스크립터를 논블록으로 열게되는데, 이 때 읽을 데이터가 없다면 read() 는 호출이 블록되는 대신 -1을 반환하면서 errno를 EAGAIN으로 설정한다.</ul><h3 id="blocking-io-model">Blocking I/O Model</h3><p><img data-proofer-ignore data-src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2a55e40d-b558-42d1-9104-a7d70dc89834/Untitled.png" alt="Untitled" /></p><ul><li>I/O 작업이 진행되는 동안 유저 프로세스는 자신의 작업을 중단한채 대기해야함. → 리소스 낭비가 심하다.<li>이를 해결하기 위해 클라이언트 별로 쓰레드를 만들어 연결시켜준다면 클라이언트 수가 늘어날 수록 쓰레드가 너무 많아진다. 이렇게 되면 context switching 횟수가 증가하게 됨. 비효율적</ul><h3 id="non-blocking-io-model">Non Blocking I/O Model</h3><p><img data-proofer-ignore data-src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f356aa6a-45a9-4f01-9520-f0e8746097d7/Untitled.png" alt="Untitled" /></p><ul><li>I/O 작업을 진행하는 동안 유저 프로세스의 작업을 중단시키지 않는다.<li>함수를 호출하면 진행상황과 상관없이 바로 결과를 반환</ul><h3 id="read-크기">read() 크기</h3><ul><li>size_t<ul><li>바이트 단위로 크기를 측정하기 위해 사용되는 값 저장<li>SIZE_MAX</ul><li>ssize_t<ul><li>부호가 있는 size_t 이다. (signed)<li>음수 에러를 포함하기 위해 사용<li>SSIZE_MAX<ul><li><em>len이 이보다 큰 경우의 read() 호출결과는 정의되어 있지 않음</em><li>32bit 기계에서는 <code class="language-plaintext highlighter-rouge">0x7ffffffff</code></ul></ul></ul><h2 id="23-write로-쓰기">2.3 Write()로 쓰기</h2><p>파일에 데이터를 기록하기 위해 사용하는 가장 기본적이며 일반적인 시스템 콜</p><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">ssize_t</span> <span class="nf">write</span> <span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">);</span>
</pre></table></code></div></div><p>count 바이트만큼 fd가 참조하는 파일의 현재 위치에 시작지점이 buf인 내용을 기록한다.</p><ul><li>return<ul><li>성공하면 쓰기에 성공한 바이트 수를 반환<li>에러가 발생하면 -1을 반환하며 errno를 적절한 값으로 설정</ul></ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="cm">/*buf에 들어있는 문자열을 fd가 가리키는 파일에 입력한다 */</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="s">"My ship is solid!"</span><span class="p">;</span>
<span class="kt">ssize_t</span> <span class="n">nr</span><span class="p">;</span>

<span class="n">nr</span> <span class="o">=</span> <span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span> <span class="p">(</span><span class="n">buf</span><span class="p">));</span>
<span class="k">if</span> <span class="p">(</span><span class="n">nr</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="cm">/* 에러 */</span>
</pre></table></code></div></div><h3 id="덧붙이기-모드">덧붙이기 모드</h3><ul><li><code class="language-plaintext highlighter-rouge">O_APPEND</code> 옵션으로 open()을 하게되면 현재 파일 오프셋이 아니라 파일 끝에서부터 쓰기 연산이 일어난다.<li>다중 프로세스가 같은 파일 수정을 진행했을 때 <code class="language-plaintext highlighter-rouge">race condition</code>이 발생한다. 이는 명시적인 동기화 과정 없이 동일 파일에 덧붙이는 작업이 불가능함을 의미함.<li><strong>덧붙이기 모드를 이용하면 프로세스가 여럿 존재할지라도 항상 덧붙이기 작업이 수행됨</strong></ul><h3 id="write-동작방식">write() 동작방식</h3><p>리눅스 커널은 디스크의 데이터를 캐싱하는데, 이를 <strong><code class="language-plaintext highlighter-rouge">페이지 캐시</code></strong>(page cache)라고 하고, 캐시되어 있던 페이지가 다시 디스크로 적용되는 것(동기화 되는 것)을 <code class="language-plaintext highlighter-rouge">page writeback</code>이라고 한다. 페이지 캐시의 최대 목적은 디스크 입출력을 최소화 시키는 데 있다.</p><ul><li>디스크 접근은 메모리 접근에 비해 상대적으로 많이 느리다. milliseconds vs nanoseconds<ul><li>L1 &gt; L2 &gt; L3 &gt; Memory &gt; Disk</ul><li>Data Locality: 최근에 사용된 데이터는 다시 사용될 가능성이 높다.</ul><h3 id="write-caching">Write caching</h3><p>3가지 동작 예상</p><ol><li><p><code class="language-plaintext highlighter-rouge">write()</code>에 대해서 이미 캐싱해놓은 데이터와는 상관없이 바로 디스크에 데이터를 내려버리는 경우.</p><p>즉, 메모리에 있는 캐시 데이터를 지나치고 바로 디스크로 데이터를 갱신한다.</p><p>이 경우에는 기존에 캐싱되어 있는 페이지 캐시는 invalidate 된다. 만약 <code class="language-plaintext highlighter-rouge">read()</code>가 해당 데이터에 대해서 들어오면 디스크로부터 읽어온다.</p><li>메모리에 있는 캐시와 디스크 모두 갱신해준다. 가장 간단한 방법으로 이러한 방식을 <strong>write-through</strong> cache<em>라고 한다. 캐시부터 디스크까지 모두 <code class="language-plaintext highlighter-rouge">write()</code> 연산이 수행된다. 이 경우 캐시와 디스크 모두를 항상 최신 상태로 만들어주기 때문에 캐시를 일관성있게 유지해준다. (cache coherent)</em><li>(현재 Linux에서 사용하고 있는 방식) <strong><em>write back</em></strong> 방식은 <code class="language-plaintext highlighter-rouge">write()</code> 요청이 들어왔을 때 페이지 캐시에만 우선 갱신하고 <em>backing store</em>에는 바로 갱신하지 않는 방식이다. 이 방식을 채택하면 cache와 원본 데이터가 서로 다르게 되며, 캐시에 있는 데이터가 최신 데이터가 된다. 최신 데이터는 캐싱이 된 이후로 업데이트가 되었다는 의미로 dirty 상태(unsynchronized)가 되며 dirty list에 추가되어 커널에 의해 관리된다. 커널은 주기적으로 dirty list에 등록되어 있는 페이지 캐시를 <em>backing store</em>에 동기화해주는데 이러한 작업을 <strong><em>writeback</em></strong>이라고 한다. <strong>writeback</strong> 방식은 <strong>write-through</strong> 방식보다 나은 방법인데, 왜냐하면 최대한 디스크에 쓰는 것을 미루어둠으로써 나중에 대량으로 병합해서 디스크에 쓸 수 있기 때문이다. 단점은 조금 더 복잡하다는 것이다.</ol><p>출처(<a href="https://scslab-intern.gitbooks.io/linux-kernel-hacking/content/chapter16.html">https://scslab-intern.gitbooks.io/linux-kernel-hacking/content/chapter16.html</a>)</p><h2 id="24-동기식-입출력">2.4 동기식 입출력</h2><blockquote><p>필요한 경우</p></blockquote><ol><li><p>디스크에 순서대로 기록해야만 하는 경우 → 커널의 대기열에서 성능 개선에 적합한 방식으로 쓰기 요청 순서를 변경하기 때문에 문제가 발생할 수 있음</p><li><p>시스템이 비정상 종료될 경우 → 버퍼에 있는 내용을 디스크에 쓰기 전에 시스템이 종료될 수 있음</p><blockquote></blockquote></ol><ul><li>분명히 입출력을 동기화 하는 것은 중요한 주제임.<li>하지만 Write 작업이 지연되는 문제를 너무 확대 해석하면 안됨.<li>최신 OS라면 버퍼를 통해서 <code class="language-plaintext highlighter-rouge">지연된 쓰기 작업</code> 을 구현하고 있다.<li>그럼에도 시점을 제어하고 싶을 때가 있기 때문에 리눅스 커널에서는 “성능”을 희생하는 대신, 입출력을 동기화하는 몇 가지 옵션을 제공한다.</ul><h3 id="fsync와-fdatasync">fsync()와 fdatasync()</h3><ul><li><code class="language-plaintext highlighter-rouge">fsync()</code>를 호출하면 fd에 맵핑된 파일의 모든 변경점을 디스크에 기록한다.<ul><li>반드시 fd는 쓰기 모드로 열려야함.</ul><li><code class="language-plaintext highlighter-rouge">fdatasync()</code>는 fsync()와 동일한 기능을 하지만, 메타데이터까지 저장하는 fsync()와는 다르게 데이터만 기록한다. 그렇기 때문에 더 빠름.</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
<span class="n">ret</span> <span class="o">=</span> <span class="n">fsync</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="cm">/* ERROR */</span>
</pre></table></code></div></div><ul><li>몇몇 리눅스 배포판에서 fdatasync()는 구현되어있지만, fsync()는 구현되어있지 않을 때도 있다. 이때는 EINVAL를 반환</ul><h3 id="sync">sync()</h3><ul><li>모든 버퍼 내용(데이터와 메타데이터 모두) 을 디스크에 강제로 기록해서 동기화함.<li>최적화는 조금 부족</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">sync</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>인자도 없고, 반환 값도 없음<li>→ 항상 호출 성공</ul><h3 id="o_sync-플래그">O_SYNC 플래그</h3><ul><li>open() 호출 시 O_SYNC 플래그를 사용하면 모든 파일 입출력은 동기화 됨.<li><em>(읽기는 언제나 동기화 됨. 하지만 write은 보통 동기화 되지 않음)</em><li>write()가 작업 후 반환하기 직전에 fsync()를 매번 호출하는 방식이라고 이해해도 좋음.<ul><li><em>(실제로 리눅스 커널에서는 좀 더 효율적인 방식으로 구현하고 있지만 의미는 동일)</em></ul><li>Latency 가 조금씩 늘어남<ul><li><strong>→ 입출력 동기화에 들어가는 비용이 매우 크기 때문에, 다른 대안을 모두 적용한 다음 최후의 선택으로 사용해야함</strong></ul><li>일반적으로 쓰기 작업이 디스크에 바로 기록되어야 하는 애플리케이션에서는 fsync()나 fdatasync()를 사용함. 이들은 호출 횟수가 적어서 O_SYNC보다 비용이 적게 듬.</ul><h3 id="o_dsync와-o_rsync">O_DSYNC와 O_RSYNC</h3><ul><li>O_DSYNC는 메타데이터를 제외한 일반 데이터만 동기화 (fdatasync()와 동일)<li>O_RSYNC는 쓰기뿐만 아니라 읽기까지도 동기화되도록 한다.<ul><li>read() 호출은 특별한 옵션 없이도 항상 동기화 되기 때문에 O_RSYNC 플래그가 특별히 필요하지 않다. 다만 최종적으로 사용자에게 넘겨줄 데이터가 생길 때 까지 반환되지 않음.<li>리눅스는 <code class="language-plaintext highlighter-rouge">O_RSYNC</code>를 <code class="language-plaintext highlighter-rouge">O_SYNC</code>와 동일하게 정의한다.<ul><li>리눅스 구현상 이런 동작을 구현하기가 쉽지 않다고 한다.</ul></ul></ul><h2 id="25-직접-입출력">2.5 직접 입출력</h2><ul><li>리눅스 커널은 디바이스와 애플리케이션 사이에 캐시, 버퍼링, 입출력 관리 같은 복잡한 계층을 구현하고 있음<li>성능이 중요한 애플리케이션에서는 우회해서 <code class="language-plaintext highlighter-rouge">직접 입출력</code>을 하고 싶을수도 있다.<ul><li>일반적으로는 노력에 비해 효과가 낮다.<li>하지만 <strong>DB시스템</strong>은 독자적인 캐시를 선호하며 OS의 개입을 최소한으로 줄이기를 원함</ul><li>O_DIRECT<ul><li>open()호출에서 <code class="language-plaintext highlighter-rouge">O_DIRECT</code>를 넘기면 커널이 입출력 관리를 최소화하도록 한다.<li>페이지 캐시를 우회해서 사용자 영역 버퍼에서 직접 디바이스로 입출력 작업을 시작한다.<li>모든 입출력은 동기식.<li>입출력 작업이 완료된 후에 호출이 반환 됨</ul></ul><h2 id="26-파일-닫기">2.6 파일 닫기</h2><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">close</span> <span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>fd로 읽고 쓰는 작업을 마치면 <code class="language-plaintext highlighter-rouge">close</code>로 파일 맵핑을 끊어야한다.<li>close()를 호출하면 fd에 연관된 파일과의 맵핑을 해제하며 프로세스에서 파일을 떼어낸다.<li>파일을 닫더라도 파일을 디스크에 강제로 쓰지 않는다는 점을 기억해야한다.<ul><li>확실히 기록하려면 <code class="language-plaintext highlighter-rouge">동기식 입출력</code> 방법 중 하나를 써야함</ul></ul><h3 id="에러-값">에러 값</h3><ul><li>지연된 연산에 의한 에러는 한참 후에도 나타나지 않기 때문에 close()의 반환값을 검사해주는 것이 중요함.<li>EBADF (파일 디스크립터가 유효하지 않음)<li>EIO (저수준의 입출력에러)</ul><h2 id="27-lseek로-탐색하기">2.7 lseek()로 탐색하기</h2><ul><li>가끔 파일의 <code class="language-plaintext highlighter-rouge">특정 위치</code>로 직접 이동해야 할 필요가 있을 떄가 있다.<li>lseek()을 사용하면 fd에 연결된 파일의 오프셋을 특정 값으로 지정할 수 있다.<li>파일 오프셋 갱신 외에 다른 동작은 하지 않고 어떤 입출력도 발생하지 않음.</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">off_t</span> <span class="nf">lseek</span> <span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">origin</span><span class="p">);</span>
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">origin</code><ul><li><strong>SEEK_CUR</strong><ul><li>fd의 파일 오프셋을 현재 오프셋에서 pos값을 더한 값으로 설정. pos값은 음수, 0, 양수 모두 가능<li>pos가 0이면 현재 파일 오프셋을 반환</ul><li><strong>SEEK_END</strong><ul><li>fd의 파일 오프셋을 현재 오프셋에서 pos값을 더한 값으로 설정. pos값은 음수, 0, 양수 모두 가능<li>pos가 0이면 파일 오프셋을 현재 파일의 끝으로 설정</ul><li><strong>SEEK_SET</strong><ul><li>fd의 파일 오프셋을 pos값으로 설정<li>pos가 0이면 파일 오프셋을 파일의 처음으로 설정</ul></ul><li>현재 파일 오프셋 찾기<ul><li>lseek()은 갱신된 파일 오프셋을 반환하므로 lseek()에 SEEK_CUR와 0을 pos값으로 넘기면 현재 파일 오프셋을 찾을 수있다.<div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">pos</span> <span class="o">=</span> <span class="n">lseek</span> <span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SEEK_CUR</span><span class="p">)</span>
</pre></table></code></div></div></ul><li>파일의 시작 혹은 끝 지점으로 오프셋을 이동하거나, 현재 오프셋을 알아내는데 많이 사용 됨!</ul><h3 id="파일-끝을-넘어서-탐색하기">파일 끝을 넘어서 탐색하기</h3><ul><li>파일 끝을 넘어서도록 위치를 지정하는 것은 아무런 일도 발생하지 않음.<li>이때 read()를 하면 <code class="language-plaintext highlighter-rouge">EOF</code>반환<li><strong>이때 write()를 하면 마지막 오프셋과 새로운 오프셋 사이에 새로운 공간이 만들어지며 <code class="language-plaintext highlighter-rouge">0</code>으로 채워짐</strong><li>0으로 채운 공간을 구멍 (<code class="language-plaintext highlighter-rouge">spare file</code>)이라고 하는데, 이 구멍들은 물리적인 디스크 공간을 차지하지 않음</ul><p>→ 파일시스템에서 모든 파일을 합친 크기가 물리적인 디스크 크기보다 더 클 수 있음</p><p>→ 이런 파일이 공간을 상당히 절약하며 효율을 크게 높일 수 있다.</p><h3 id="제약사항">제약사항</h3><ul><li>파일 오프셋의 최댓값은 <code class="language-plaintext highlighter-rouge">off_t</code>의 크기에 제한됨.<ul><li>커널은 내부적으로 오프셋 값을 C의 long long타입으로 저장<li>64비트 머신에서는 문제가 되지 않지만, 32비트 머신에서는 EOVERFLOW 에러 발생 가능</ul></ul><h2 id="28-지정한-위치-읽고-쓰기">2.8 지정한 위치 읽고 쓰기</h2><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">ssize_t</span> <span class="nf">pread</span> <span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">pos</span><span class="p">);</span>
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">pread()</code>를 사용하면 fd에서 pos오프셋에 있는 데이터를 buf에 count 바이트만큼 읽는다.</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">ssize_t</span> <span class="nf">pwrite</span> <span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">pos</span><span class="p">);</span>
</pre></table></code></div></div><ul><li><p><code class="language-plaintext highlighter-rouge">pwrite()</code>를 사용하면 buf에 담긴 데이터를 fd의 pos 오프셋에 count 파이트만큼 쓴다.</p><li>둘 모두 작업 후 파일 오프셋을 갱신하지 않는다.<li>둘 모두 현재 파일의 오프셋을 무시하며 pos로 지정한 오프셋을 사용한다는 점을 제외하고는 read()와 write() 시스템 콜과 거의 유사하게 동작한다.<li>read() 나 write() 호출 전에 lseek()을 호출하는 방식과 유사하지만 3가지 차이점이 존재<ol><li>작업 후 파일 오프셋을 원위치로 되돌리거나 임의의 오프셋에 접근해야 하는 경우 쉽게 사용가능<li>호출이 완료된 후 파일 포인터를 갱신하지 않음<li>lseek()를 사용할 때 발생할 수 있는 경쟁 상태를 피할 수 있다.<ul><li>lseek()은 본질적으로 여러 스레드에서 같은 fd를 처리할 경우 안전하지가 않음. race condition 발생 가능.</ul></ol></ul><h3 id="에러-값-1">에러 값</h3><ul><li>두 함수는 호출이 성공하면 읽거나 쓴 바이트 개수를 반환함.<li>pread() 0반환 : EOF<li>pwrite() 0 반환 : 아무런 데이터도 쓰지 못했음<li>pread()는 read()와 lseek()에서 허용하는 errno 값을 설정<li>pwrite()는 write()와 lseek()에서 허용하는 errno 값을 설정</ul><h2 id="29-파일-잘라내기">2.9 파일 잘라내기</h2><p>파일을 특정 길이만큼 잘라내기 위한 시스템 콜</p><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">ftruncate</span> <span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">len</span><span class="p">)</span>
</pre></table></code></div></div><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">truncate</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">len</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>두 시스템 콜은 모두 파일을 len 크기만큼 잘라낸다.<li><code class="language-plaintext highlighter-rouge">ftruncate()</code>는 쓰기 모드로 열린 fd에 대해 동작.<li><code class="language-plaintext highlighter-rouge">truncate()</code>는 쓰기 권한이 있는 파일 경로에 대해서 동작<li>성공<ul><li>둘 다 0을 반환</ul><li>에러<ul><li>-1 반환, errno를 적절한 값으로 설정함.</ul><li>호출이 성공하면 파일의 길이는 len이 된다. len과 자르기 전의 파일 크기 사이에 존재하던 데이터는 없어지고, read()를 통해 이 영역에 접근할 수 없게 됨.</ul><h2 id="210-다중-입출력">2.10 다중 입출력</h2><ul><li>논블록 입출력이 효과적이지 않은 두가지 이유<ol><li>프로세스는 계속 열린 fd 중 하나가 입출력을 준비할 때까지 기다리면서 어떤 임의의 순서대로 입출력을 요청해야 한다.<li>프로세스를 재워 다른 작업을 처리하게 하고 fd가 입출력을 수행할 준비가 되면 깨우는 편이 더 효과적일 수 있음. 논블록 입출력으로 이것을 해결할 수 있지만 프로세스가 계속 깨워져있어야 한다는 단점이 존재한다.</ol><li><code class="language-plaintext highlighter-rouge">다중 입출력</code>은 애플리케이션이 여러개의 fd를 동시에 블록하고 그중 하나라도 블록되지 않고 읽고 쓸 준비가 되면 알려주는 기능을 제공<blockquote><ol><li>다중 입출력: fd 중 하나가 입출력이 가능할 때 알려준다.<li>준비가 됐나? 준비된 fd가 없다면 하나 이상의 fd가 준비될 때까지 잠든다.<li>깨어나기. 어떤 fd가 준비됐나?<li>블록하지 않고 모든 fd가 입출력을 준비하도록 관리한다.<li>1로 돌아가서 다시 시작한다.</ol></blockquote></ul><h3 id="select">select()</h3><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">select</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span>
						<span class="n">fd_set</span> <span class="o">*</span><span class="n">readfds</span><span class="p">,</span>
						<span class="n">fd_set</span> <span class="o">*</span><span class="n">writefds</span><span class="p">,</span>
						<span class="n">fd_set</span> <span class="o">*</span><span class="n">exceptfds</span><span class="p">,</span>
						<span class="k">struct</span> <span class="o">*</span><span class="n">timeval</span> <span class="o">*</span><span class="n">timeout</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">timeval</span> <span class="p">{</span>
	<span class="kt">long</span> <span class="n">tv_sec</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">tv_usec</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">select()</code> 호출은 fd가 입출력을 수행할 준비가 되거나 옵션으로 정해진 시간이 경과할 때까지만 블록된다.<li>파라미터<ul><li><code class="language-plaintext highlighter-rouge">n</code><ul><li>fd 집합에서 가장 큰 fd 숫자에 1을 더한 값<li>즉, fd에서 가장 큰 값이 무엇인지 알아내서 1 더해야 함.</ul><li><code class="language-plaintext highlighter-rouge">readfds</code><ul><li>블록되지 않고 read()작업이 가능한지를 파악하기 위해 감시</ul><li><code class="language-plaintext highlighter-rouge">writefds</code><ul><li>블록되지 않고 write()작업이 가능한지를 파악하기 위해 감시</ul><li><code class="language-plaintext highlighter-rouge">exceptfds</code><ul><li>예외가 발생했거나 대역을 넘어서는 데이터 (이는 소켓에만 적용) 가 존재하는지 감시</ul><li><em>→ 어떤 집합이 NULL이면 해당 이벤트 감시하지 않음</em><li><code class="language-plaintext highlighter-rouge">timeout</code><ul><li>NULL이 아니면 입출력이 준비된 fd가 없을 경우에도 tv_sec, tv_usec 이후에 반환됨.<li>두 값이 모두 0이면 호출은 즉시 반환됨.</ul></ul><li>호출이 성공하면<ul><li>각 집합은 요청받은 입출력 유형을 대상으로 입출력이 준비된 fd만 포함하도록 변경된다.<li>ex) 7과 9인 두개의 fd가 readfds에 들어있다고 한다면 호출이 반환될 때 7이 집합에 남아있고 9가 남아있지 않다면, 7은 블록없이 읽기 가능! 9는 아마도 읽기 요청이 블록될 것임</ul><li>select()에서 사용하는 fd집합은 직접 조작하지 않고 매크로를 사용해서 관리함</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">FD_CLR</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span><span class="n">set</span><span class="p">);</span>
<span class="n">FD_ISSET</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span><span class="n">set</span><span class="p">);</span>
<span class="n">FD_SET</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span><span class="n">set</span><span class="p">);</span>
<span class="n">FD_ZERO</span><span class="p">(</span><span class="n">fd_set</span> <span class="o">*</span><span class="n">set</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>FD_ZERO 는 지정된 집합내의 모든 fd를 제거함. 항상 select() 호출 전에 사용해야함<li>FD_SET은 주어진 집합에 fd를 추가함<li>FD_CLR은 주어진 집합에서 fd를 하나 제거함<ul><li>제대로 설계된 코드라면 FD_CLR을 사용할 일이 절대 없음!</ul><li>FD_ISSET은 fd가 주어진 집합에 존재하는지 검사<ul><li>집합에 들어있다면 0이 아닌 정수 반환. 들어있지 않다면 0반환</ul></ul><h3 id="반환값과-에러코드">반환값과 에러코드</h3><ul><li>호출 성공<ul><li>전체 세 가지 집합 중에서 입출력이 준비된 fd개수를 반환함.<li>timeout을 초과하면 반환값이 0이 될 수 있다.</ul><li>에러 발생<ul><li>-1 반환, errno 설정</ul></ul><h3 id="select-예제">select() 예제</h3><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/time.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span>
<span class="cp">#define TIMEOUT 5
#define BUF_LEN 1024
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">timeval</span> <span class="n">tv</span><span class="p">;</span>
    <span class="n">fd_set</span> <span class="n">readfds</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

    <span class="c1">// 표준 입력에서 입력을 기다리기 위한 준비를 합니다.</span>
    <span class="n">FD_ZERO</span><span class="p">(</span><span class="o">&amp;</span><span class="n">readfds</span><span class="p">);</span>
    <span class="n">FD_SET</span><span class="p">(</span><span class="n">STDIN_FILENO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">readfds</span><span class="p">);</span>

    <span class="c1">// select가 5초 동안 기다리도록 timeval 구조체를 설정합니다.</span>
    <span class="n">tv</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">TIMEOUT</span><span class="p">;</span>
    <span class="n">tv</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// select() 시스템콜을 이용해 입력을 기다립니다.</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">STDIN_FILENO</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">readfds</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tv</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"select"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">){</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d seconds elapsed.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">TIMEOUT</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// select() 시스템콜이 양수를 반환했다면 '블록(block)'없이 즉시 읽기가 가능합니다.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">FD_ISSET</span><span class="p">(</span><span class="n">STDIN_FILENO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">readfds</span><span class="p">))</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">BUF_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

        <span class="c1">// '블록(block)'없이 읽기가 가능합니다.</span>
        <span class="n">len</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">STDIN_FILENO</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">BUF_LEN</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">buf</span><span class="p">[</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"read: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="select로-구현하는-이식-가능한-sleep">select()로 구현하는 이식 가능한 sleep</h3><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">tv</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">tv</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="mi">500</span><span class="p">;</span>

<span class="n">select</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tv</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>역사적으로 select()는 1초 미만의 짧은 시간 동안 프로세스를 재울 수 있는 더 나은 방법을 제공해왔음<li>최신 리눅스는 아주 짧은 시간 잠들기 인터페이스를 지원하고 있음</ul><h3 id="pselect">pselect()</h3><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">pselect</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span>
						<span class="n">fd_set</span> <span class="o">*</span><span class="n">readfds</span><span class="p">,</span>
						<span class="n">fd_set</span> <span class="o">*</span><span class="n">writefds</span><span class="p">,</span>
						<span class="n">fd_set</span> <span class="o">*</span><span class="n">exceptfds</span><span class="p">,</span>
						<span class="k">struct</span> <span class="o">*</span><span class="n">timespec</span> <span class="o">*</span><span class="n">timeout</span><span class="p">,</span>
						<span class="k">const</span> <span class="n">sigset_t</span> <span class="o">*</span><span class="n">sigmask</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">timespec</span> <span class="p">{</span>
	<span class="kt">long</span> <span class="n">tv_sec</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">tv_nsec</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>select()와의 차이점<ol><li>pselect()는 timeout 인자로 timeval 구조체 대신 timespec 구조체를 사용. 이는 초, 나노 초 조합을 사용하므로 이론적으로 더 짧은 시간 동안 잠들 수 있다. <em>하지만 실제로는 둘 다 마이크로 초도 확실히 지원하지 못함..</em><li>pselect()는 timeout 인자를 변경하지 않기 때문에 잇달은 호출 과정에서 timeout 인자를 계속 초기화해야 할 필요가 없다.<li>select() 시스템 콜은 sigmask 인자를 받지 않는다. 이 인자는 NULL로 설정하면 pselect()는 select()와 동일하게 동작한다.</ol><li>pselect()가 추가된 이유<ul><li>fd와 시그널을 기다리는 사이에 발생할 수 있는 race condition 을 해결하기 위한 sigmask 인자를 추가하기 위함이다.<li>블록할 시그널 목록을 인자로 받아서 select() 도중에 시그널이 도착하는 경우에도 이를 처리함.<li>sigmask가 가리키는 신호마스크가 자동으로 설정되어 차단되고, pselect() 호출이 반환될 때는 신호마스크가 복원되어 실행하게 된다.</ul></ul><h3 id="poll">poll()</h3><ul><li>select()의 몇 가지 결점을 보완함.<ul><li>select()는 ‘읽기, 쓰기 예외’ 3가지를 독립적으로 설정하고 매개변수로 넘겨줘야했다. 하지만 poll은 구조체 배열을 사용함으로써 설계상으로도 훨씬 더 좋아졌음.</ul><li>그럼에도 불구하고 여전히 습관이나 이식성의 이유료 select()를 더 많이 사용함</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">poll</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pollfd</span> <span class="o">*</span><span class="n">fds</span><span class="p">,</span> <span class="n">nfds_t</span> <span class="n">nfds</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">pollfd</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
	<span class="kt">short</span> <span class="n">events</span><span class="p">;</span>
	<span class="kt">short</span> <span class="n">revents</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><ul><li>fds가 가리키는 단일 pollfd 구조체 배열을 nfds 개수만큼 사용함.<li><em>events 필드는 fd에서 감시할 이벤트의</em> <code class="language-plaintext highlighter-rouge">비트마스크</code> <em>를 의미</em><ul><li>POLLIN - 읽을 데이터가 존재한다. 즉, 읽기가 블록(blokc)되지 않는다.<li>POLLRDNORM - 일반 데이터를 읽을 수 있다.<li>POLLRDBAND - 우선권이 있는 데이터를 읽을 수 있다.<li>POLLPRI - 시급히 읽을 데이터가 존재한다.<li>POLLOUT - 쓰기가 블록(block)되지 않는다.<li>POLLWRNORM - 일반 데이터 쓰기가 블록(block)되지 않는다.<li>POLLWRBAND - 우선권이 있는 데이터 쓰기가 블록(block)되지 않는다.<li>POLLMSG - SIGPOLL 메시지가 사용 가능하다.</ul><li>events를 설정하면 등록한 이벤트 중 발생한 이벤트가 revents필드에 설정된다.<li>revents 필드는 등록한 이벤트 중 발생된 이벤트 정보를 커널이 설정해줌.<li><p><em>revents 필드에는 다음 이벤트가 설정될 수 있다.</em></p><ul><li>POLLER - 주어진 파일 디스크립터에 에러가 있다.<li>POLLHUP - 주어진 파일 디스크립터에서 이벤트가 지체되고 있다.<li>POLLNVAL - 주어진 파일 디스크립터가 유효하지 않다.</ul><li>예제1<ul><li><div class="table-wrapper"><table><tbody><tr><td>fd의 읽기와 쓰기를 감시하려면 events 를 POLLIN<td>POLLOUT으로 설정</table></div><li>호출이 반환되면 pollfd 구조체 배열에서 원하는 fd가 들어있는 항목을 찾아 revents에 해당 플래그가 켜져있는지 확인한다.<li>POLLIN 이 설정되어 있다면 읽기는 블록되지 않음.<li>POLLOUT이 설정되어 있다면 쓰기는 블록되지 않는다.</ul><li><p>예제2</p><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;poll.h&gt;</span><span class="cp">
</span>
<span class="cp">#define TIMEOUT 5
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">pollfd</span> <span class="n">fds</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

    <span class="c1">// 표준 입력에 대한 이벤트를 감시하기 위한 준비를 한다</span>
    <span class="n">fds</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">fd</span> <span class="o">=</span> <span class="n">STDIN_FILENO</span><span class="p">;</span>
    <span class="n">fds</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">events</span> <span class="o">=</span> <span class="n">POLLIN</span><span class="p">;</span>

    <span class="c1">// 표준 출력에 쓰기가 가능한지 감시하기 위한 준비를 한다.</span>
    <span class="n">fds</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">fd</span> <span class="o">=</span> <span class="n">STDOUT_FILENO</span><span class="p">;</span>
    <span class="n">fds</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">events</span> <span class="o">=</span> <span class="n">POLLOUT</span><span class="p">;</span>

    <span class="c1">// 위에서 pollfd 구조체 설정을 모두 마쳤으니 poll() 시스템콜을 작동시킨다.</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">poll</span><span class="p">(</span><span class="n">fds</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">TIMEOUT</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"poll"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span><span class="c1">//타임아웃</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d seconds elapsed.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">TIMEOUT</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">fds</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">revents</span> <span class="o">&amp;</span> <span class="n">POLLIN</span><span class="p">)</span> <span class="n">printf</span><span class="p">(</span><span class="s">"stdin is readable</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fds</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">revents</span> <span class="o">&amp;</span> <span class="n">POLLOUT</span><span class="p">)</span> <span class="n">printf</span><span class="p">(</span><span class="s">"stdout is writeable</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div></ul><h3 id="ppoll">ppoll()</h3><ul><li>ppoll()은 리눅스에서만 사용가능한 인터페이스<li>pselect() 처럼 timeout 인자는 나노 초 단위로 지정 가능하며 블록할 시그널 집합은 sigmask 인자로 제공</ul><h3 id="poll과-select-비교">poll()과 select() 비교</h3><ul><li>비슷한 작업을 하지만 poll은 select 보다 훨씬 유용함!<ol><li>poll은 가장 높은 파일 fd값에다가 1을 더해서 인자로 전달할 필요 없음<li>select에서 값이 900인 fd를 감시하게되면 매번 fd 집합에서 900번째 비트까지 일일히 검사해야함<li>select 의 fd 집합은 크기가 정해져있어서 트레이드 오프가 발생함. poll은 딱 맞는 크기의 fd 집합을 사용함<li>select 는 fd 집합을 반환하는 시점에서 재구성되므로 매번 fd 집합을 초기화해야함. poll은 event(입력), revent(출력)이 분리되어있다.<li>select 의 timeout 인자는 반환하게 되면 미정의 상태가 됨.</ol></ul><h2 id="211-커널-들여다보기">2.11 커널 들여다보기</h2><h3 id="가상-파일-시스템vfs">가상 파일 시스템(<code class="language-plaintext highlighter-rouge">VFS</code>)</h3><ul><li>사용 중인 파일시스템이 무엇인지 몰라도 파일시스템 데이터를 처리하고 파일 시스템 함수를 호출할 수 있도록 하는 추상화 메커니즘<li>추상화를 위해서 리눅스에서 모든 파일시스템의 기초가 되는 공통 파일 모델을 제공함.<li>일반적인 시스템 콜(read, write) 등은 커널이 지원하는 어떠한 파일시스템이나 매체에서도 파일을 다룰 수 있다</ul><h3 id="페이지-캐시">페이지 캐시</h3><ul><li>디스크 파일 시스템에서 최근에 접근한 데이터를 저장하는 메모리 저장소<li>메모리에 쓰기를 요청한 데이터를 저장하면 동일한 데이터에 대한 요청이 연이어 발생할 경우 커널은 반복적인 Disk 접근을 피해서 메모리에서 바로 처리할 수 있다.<li>Temporal Locality 라는 개념을 활용함<ul><li>특정 시점에서 리소스에 접근하면 오래 지나지 않은 장래에 다시 또 접근할 가능성이 높다는 이론</ul><li>Sequential Locality<ul><li>데이터가 순차적으로 참조됨을 뜻함<li>이를 활용하기 위해 페이지 캐시 미리 읽기를 구현하고 있음</ul><li>커널이 파일시스템 데이터를 탐색하는 첫번째 장소가 <code class="language-plaintext highlighter-rouge">페이지 캐시</code> 이다.<li>동적으로 페이지 캐시 크기 변경 가능<ul><li>메모리가 가득차게되면 페이지 캐시 중에서 가장 적게 사용한 페이지를 삭제해서 메모리를 확보한다.<li>이런 작업은 자동적으로 매끄럽게 일어남.</ul><li><h2 id="디스크-스왑과-캐시-삭제-간의-균형을-맞추는-데는-휴리스틱-기법을-사용함">디스크 스왑과 캐시 삭제 간의 균형을 맞추는 데는 <code class="language-plaintext highlighter-rouge">휴리스틱 기법</code>을 사용함</h2></ul><h3 id="페이지-쓰기-저장">페이지 쓰기 저장</h3><ul><li>커널은 버퍼를 통해 쓰기 작업을 지연시킨다.<li>쓰기 요청을 하면 버퍼로 데이터를 복사한 다음 버퍼에 변경 표시를 하여 디스크에 있는 복사본보다 메모리에 있는 복사본이 새롭다고 알려준다. 그러면 쓰기 요청은 바로 반환된다.<li>최종적으로 버퍼에 있는 내용이 디스크로 반영되어 디스크와 메모리에 있는 데이터가 동기화가 되어야하는데 이를 <code class="language-plaintext highlighter-rouge">쓰기 저장</code>이라고 한다. 두 가지 상황에서 발생함<ul><li>여유 메모리가 설정된 경계 값 이하로 줄어들면 변경된 버퍼를 디스크에 기록한 다음, 버퍼를 삭제해서 메모리 공간을 확보한다.<li>설정된 값보다 오랫동안 유지된 버퍼는 디스크에 기록된다. 이는 변경된 버퍼가 무한정 메모리에만 남아있는 상황을 방지한다.</ul><li>쓰기 저장은 <code class="language-plaintext highlighter-rouge">Flusher</code> 스레드 라고 하는 커널 스레드 무리에서 수행함</ul><h2 id="212-마무리">2.12 마무리</h2><ul><li>가능한 모든 것을 파일로 표현하는 리눅스 같은 시스템에서는 어떻게 파일을 열고, 읽고, 쓰고, 닫는지 이해하는 것이 매우 중요하다. 이 모든 연산은 유닉스의 고전이며 여러 표준에 기술되어 있다.</ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/linux/'>Linux</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/blog/" class="post-tag no-text-decoration" >blog</a> <a href="/tags/jekyll/" class="post-tag no-text-decoration" >jekyll</a> <a href="/tags/jekyll-theme/" class="post-tag no-text-decoration" >jekyll theme</a> <a href="/tags/next-theme/" class="post-tag no-text-decoration" >NexT theme</a> <a href="/tags/computer-science/" class="post-tag no-text-decoration" >Computer Science</a> <a href="/tags/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B3%B5%ED%95%99/" class="post-tag no-text-decoration" >컴퓨터공학</a> <a href="/tags/%EA%B0%9C%EB%B0%9C/" class="post-tag no-text-decoration" >개발</a> <a href="/tags/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4/" class="post-tag no-text-decoration" >소프트웨어</a> <a href="/tags/%EC%A7%80%ED%82%AC-%ED%85%8C%EB%A7%88/" class="post-tag no-text-decoration" >지킬 테마</a> <a href="/tags/%EC%A7%80%ED%82%AC-%EB%B8%94%EB%A1%9C%EA%B7%B8-%ED%8F%AC%EC%8A%A4%ED%8C%85/" class="post-tag no-text-decoration" >지킬 블로그 포스팅</a> <a href="/tags/github-pages/" class="post-tag no-text-decoration" >GitHub Pages</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=[Linux System Programming] Ch02 파일 입출력 - Hans H. Kim&url=https://hhhyunwoo.github.io//posts/linux_ch02/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=[Linux System Programming] Ch02 파일 입출력 - Hans H. Kim&u=https://hhhyunwoo.github.io//posts/linux_ch02/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=[Linux System Programming] Ch02 파일 입출력 - Hans H. Kim&url=https://hhhyunwoo.github.io//posts/linux_ch02/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/blog-newjourney/">🏢 첫번째 퇴사, 첫번째 이직</a><li><a href="/posts/k8s-nginx-413-error/">[K8S] Ingress Nginx 413 http error (payload too large) 이슈 해결</a><li><a href="/posts/infiniband-nccl-issue/">[Infiniband] NCCL WARN Call to ibv_reg_mr failed 이슈 해결</a><li><a href="/posts/k8s_service/">[Kubernetes] Kubernetes 서비스 정리(ClusterIP, Nodeport, Loadbalancer) </a><li><a href="/posts/k8s-kernel-epoll-etcd-leader/">[K8S] 5.4.0-132 커널의 epoll 버그로 인한 etcd leader election 이슈</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/blog/">blog</a> <a class="post-tag" href="/tags/github-pages/">GitHub Pages</a> <a class="post-tag" href="/tags/jekyll-theme/">jekyll theme</a> <a class="post-tag" href="/tags/jekyll/">jekyll</a> <a class="post-tag" href="/tags/next-theme/">NexT theme</a> <a class="post-tag" href="/tags/%EC%A7%80%ED%82%AC-%EB%B8%94%EB%A1%9C%EA%B7%B8-%ED%8F%AC%EC%8A%A4%ED%8C%85/">지킬 블로그 포스팅</a> <a class="post-tag" href="/tags/%EC%A7%80%ED%82%AC-%ED%85%8C%EB%A7%88/">지킬 테마</a> <a class="post-tag" href="/tags/computer-science/">Computer Science</a> <a class="post-tag" href="/tags/%EA%B0%9C%EB%B0%9C/">개발</a> <a class="post-tag" href="/tags/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4/">소프트웨어</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/docker/"><div class="card-body"> <span class="timeago small" >Feb 7, 2022<i class="unloaded">2022-02-07T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Docker] Centos Image 에서 sudo command not found 에러</h3><div class="text-muted small"><p> Centos Image 에서 sudo command not found centos/python-36-centos7 이미지 사용 도중 Dockerfile 내부에서 커맨드로 파일의 모드를 바꿔야할 일이 생겼다. RUN sudo chmod 755 start.sh 근데 sudo 를 실행했을 떄 /bin/sh: sudo: command not fo...</p></div></div></a></div><div class="card"> <a href="/posts/First-post/"><div class="card-body"> <span class="timeago small" >Nov 12, 2021<i class="unloaded">2021-11-12T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>First Post</h3><div class="text-muted small"><p> Welcome Hello world, this is my first Jekyll blog post. I hope you like it!</p></div></div></a></div><div class="card"> <a href="/posts/tb07-jekyll-bundler-error/"><div class="card-body"> <span class="timeago small" >Nov 13, 2021<i class="unloaded">2021-11-13T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Trouble Shooting] Jekyll chirpy 템플릿으로 Github 블로그 시작하기. (Bundler Install Error)</h3><div class="text-muted small"><p> Jekyll chirpy 템플릿으로 Github 블로그 시작하기. (Bundler Install Error) Github 블로그 with Chirpy Jekyll Theme github 블로그를 시작할 때 Jekyll을 많이 사용한다. 그럼 Jekyll이 무엇일까? Jekyll? 텍스트 변환 엔진으로, Markup 언어로 글을 작성하면 이...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/blockchain/" class="btn btn-outline-primary" prompt="Older"><p>[BlockChain] Blockchain Transaction flow</p></a> <a href="/posts/linux_ch03/" class="btn btn-outline-primary" prompt="Newer"><p>[Linux System Programming] Ch03 버퍼 입출력</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://github.com/hhhyunwoo">Hans H. Kim</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/blog/">blog</a> <a class="post-tag" href="/tags/github-pages/">GitHub Pages</a> <a class="post-tag" href="/tags/jekyll-theme/">jekyll theme</a> <a class="post-tag" href="/tags/jekyll/">jekyll</a> <a class="post-tag" href="/tags/next-theme/">NexT theme</a> <a class="post-tag" href="/tags/%EC%A7%80%ED%82%AC-%EB%B8%94%EB%A1%9C%EA%B7%B8-%ED%8F%AC%EC%8A%A4%ED%8C%85/">지킬 블로그 포스팅</a> <a class="post-tag" href="/tags/%EC%A7%80%ED%82%AC-%ED%85%8C%EB%A7%88/">지킬 테마</a> <a class="post-tag" href="/tags/computer-science/">Computer Science</a> <a class="post-tag" href="/tags/%EA%B0%9C%EB%B0%9C/">개발</a> <a class="post-tag" href="/tags/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4/">소프트웨어</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-EPY53PE167"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-EPY53PE167'); }); </script>
