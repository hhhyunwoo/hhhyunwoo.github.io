<!DOCTYPE html><html lang="en" mode="light" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="[Linux System Programming] Ch04 고급 버퍼 입출력" /><meta property="og:locale" content="en" /><meta name="description" content="[Ch04 고급 버퍼 입출력]" /><meta property="og:description" content="[Ch04 고급 버퍼 입출력]" /><link rel="canonical" href="https://hhhyunwoo.github.io//posts/linux_ch04/" /><meta property="og:url" content="https://hhhyunwoo.github.io//posts/linux_ch04/" /><meta property="og:site_name" content="Hans H. Kim" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-03-21T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[Linux System Programming] Ch04 고급 버퍼 입출력" /><meta name="twitter:site" content="@twitter_username" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-07-10T15:41:43+09:00","datePublished":"2022-03-21T00:00:00+09:00","description":"[Ch04 고급 버퍼 입출력]","headline":"[Linux System Programming] Ch04 고급 버퍼 입출력","mainEntityOfPage":{"@type":"WebPage","@id":"https://hhhyunwoo.github.io//posts/linux_ch04/"},"url":"https://hhhyunwoo.github.io//posts/linux_ch04/"}</script><title>[Linux System Programming] Ch04 고급 버퍼 입출력 | Hans H. Kim</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Hans H. Kim"><meta name="application-name" content="Hans H. Kim"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/newyork_hw.jpeg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Hans H. Kim</a></div><div class="site-subtitle font-italic">Machine Learning Engineer <br> <br> Keep Blizt and Be Simple</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/all-posts/" class="nav-link"> <i class="fa-fw fas fa-blog ml-xl-3 mr-xl-3 unloaded"></i> <span>POSTS</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/hhhyunwoo" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['hyunwoo.h.kim','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>[Linux System Programming] Ch04 고급 버퍼 입출력 </span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>[Linux System Programming] Ch04 고급 버퍼 입출력</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Hans H. Kim </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Mon, Mar 21, 2022, 12:00 AM +0900" >Mar 21, 2022<i class="unloaded">2022-03-21T00:00:00+09:00</i> </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Sun, Jul 10, 2022, 3:41 PM +0900" >Jul 10, 2022<i class="unloaded">2022-07-10T15:41:43+09:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="13131 words">72 min read</span></div></div><div class="post-content"><h1 id="ch04-고급-버퍼-입출력">[Ch04 고급 버퍼 입출력]</h1><p>2장에서는 파일입출력의 근본일 뿐만 아니라, 리눅스에서 일어나는 모든 통신의 토대인 기본 입출력 <code class="language-plaintext highlighter-rouge">시스템 콜</code>을 배웠다.</p><p>3장에서는 기본 입출력 시스템 콜에 <code class="language-plaintext highlighter-rouge">사용자 영역 버퍼링</code>이 필요한 때를 알아보고 해법으로 <code class="language-plaintext highlighter-rouge">C언어의 표준 입출력 라이브러리</code>에 대해 공부했다.</p><p><strong>4장에서는 리눅스의 <code class="language-plaintext highlighter-rouge">고급 입출력 시스템 콜</code>에 대해 알아본다.</strong></p><h3 id="벡터-입출력">벡터 입출력</h3><ul><li>한번의 호출로 여러 버퍼에서 데이터를 읽거나 쓸 수 있도록 해줌.<li><strong>다양한 자료구조</strong>를 단일 입출력 트랜젝션으로 다룰 때 유용하다.</ul><h3 id="epoll">epoll</h3><ul><li>poll()과 select() 시스템 콜을 개선한 시스템 콜이다.<li><strong>싱글 스레드에서 수백 개의 FD를 poll해야 하는 경우에 유용</strong>하다.</ul><h3 id="메모리맵-입출력">메모리맵 입출력</h3><ul><li>파일을 <code class="language-plaintext highlighter-rouge">메모리</code>에 맵핑해서 간단한 메모리 조작을 통해 파일 입출력을 수행함.<li>특정 패턴의 입출력에 유용하다.</ul><h3 id="파일-활용법-조언">파일 활용법 조언</h3><ul><li>프로세스에서 <code class="language-plaintext highlighter-rouge">파일을 사용하려**의도**</code>를 커널에게 제공할수 있도록 하여, 입출력 성능을 향상시킴.</ul><h3 id="비동기식-입출력">비동기식 입출력</h3><ul><li>작업 완료를 기다리지 않는 입출력을 요청한다.<li>스레드를 사용하지 않고 동시에 입출력 부하가 많은 작업을 처리할 경우 유용함</ul><h1 id="41-벡터-입출력">4.1 벡터 입출력</h1><ul><li>한번의 시스템 콜을 사용해서 여러개의 버퍼 벡터에 쓰거나, 여러 개의 버퍼 벡터로 읽어 들일 때 사용하는 입출력 메서드<ul><li><em>2장의 표준 읽기와 쓰기는 <code class="language-plaintext highlighter-rouge">선형 입출력</code>이라고 함.</em></ul><li>벡터 입출력의 장점<ul><li><strong>좀 더 자연스러운 코딩 패턴</strong> - 미리 정의된 구조체의 여러 필드에 걸쳐서 데이터가 분리되어 있는 경우, 벡터 입출력을 사용하면 직관적인 방법으로 조작할 수 있음<li><strong>효율</strong> - 한번의 사용으로 여러번의 선형 입출력 연산을 대체할 수 있음<li><strong>성능</strong> - 시스템 콜 호출 횟수 ⬇️, 내부적으로 최적화된 구현을 제공<li><strong>원자성</strong> - 벡터 입출력 연산 중에 다른 프로세스가 끼어들 수 없음</ul></ul><h2 id="411-readv-와-writev">4.1.1 readv() 와 writev()</h2><ul><li><code class="language-plaintext highlighter-rouge">readv()</code> 함수는 fd에서 데이터를 읽어서 count 개수만큼 iov 버퍼에 저장한다.</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">ssize_t</span> <span class="nf">readv</span> <span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">writev()</code> 함수는 count 개수만큼 iov 버퍼에 있는 데이터를 fd에 기록함</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">ssize_t</span> <span class="nf">writev</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>readv()와 writev() 함수는 여러 개의 버퍼를 사용한다는 점에서 read(), write()와 구분됨<li><code class="language-plaintext highlighter-rouge">iovec</code> 구조체는 세그먼트라고 하는 독립적으로 분리된 버퍼를 나타낸다.</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">iovec</span><span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">iov_base</span><span class="p">;</span> <span class="c1">// 버퍼의 시작 포인터</span>
	<span class="kt">size_t</span> <span class="n">iov_len</span><span class="p">;</span> <span class="c1">// 버퍼 크기 (바이트)</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>이런 세그먼트의 집합을 <code class="language-plaintext highlighter-rouge">벡터</code>라고 한다.<li>벡터의 각 세그먼트에는 데이터를 기록하거나 읽어올 메모리 공간의 주소와 크기가 저장되어 있다.<li>두 함수는 각 버퍼에 iov_len 바이트만큼 데이터를 채우거나 쓴 다음, 다음 버퍼로 넘어간다.<li>두 함수 모드 iov[0] 부터 시작해서 iov[1], 그리고 iov[count-1]까지 세그먼트 순서대로 동작한다.</ul><h3 id="반환값">반환값</h3><ul><li>두 함수는 호출이 성공했을 때 읽거나 쓴 <code class="language-plaintext highlighter-rouge">바이트 개수</code>를 반환함<ul><li><strong>반환값은 반드시 count * iov_len 값과 같아야함.</strong></ul><li>에러 발생 시 <code class="language-plaintext highlighter-rouge">-1</code>을 반환, errno 를 설정<li><p>각각 read(), write() 시스템 콜에서 발생 가능한 모든 종류의 에러가 발생할 수 있음</p><ul><li><p>추가로 두 가지 에러 상황을 정의하고 있음</p><ol><li>반환값의 자료형이 <code class="language-plaintext highlighter-rouge">ssize_t</code> 이기 때문에, 만약 count * iov_len 값이 <code class="language-plaintext highlighter-rouge">SSIZE_MAX</code>보다 큰 경우에는 데이터가 전송되지 않고 -1을 반환하며 errno 는 <code class="language-plaintext highlighter-rouge">EINVAL</code>로 설정됨<li><p>POSIX에서는 count가 0보다 크고 <code class="language-plaintext highlighter-rouge">IOV_MAX</code>(<em>리눅스에서는 현재 1024로 정의하고 있음</em>) 와 같거나 작아야 한다고 명시하고 있는데, 만약 count가 0이라면 readv()와 writev()는 0을 반환한다.</p><p>만약 count 값이 <code class="language-plaintext highlighter-rouge">IOV_MAX</code>보다 크다면 데이터는 전송되지 않고 -1을 반환하며 errno는 <code class="language-plaintext highlighter-rouge">EINVAL</code>로 설정됨</p></ol></ul></ul><h3 id="최적-count-찾기">최적 count 찾기</h3><ul><li>벡터 입출력 작업을 할 때 리눅스 커널에서는 각 세그먼트를 위해 내부 데이터 구조체를 반드시 할당하게 됨!<li>근데 이 할당은 count의 크기에 따라 동적으로 일어난다.<li><strong>만약 count값이 크지 않다면 스택에 미리 만들어둔 작은 세그먼트 배열을 사용</strong>해서, 동적 할당이 일어나지 않도록한다. → <code class="language-plaintext highlighter-rouge">성능 개선</code>! (아주 효율적으로 동작함)<li>그러니깐 벡터 입출력 연산을 사용할 때 세그먼트의 개수의 감이 오지 않는다면 <strong>8 이하</strong>로 시도~~</ul><h3 id="예제">예제</h3><ul><li><code class="language-plaintext highlighter-rouge">writev()</code> 예제<li>3개의 벡터 세그먼트에 데이터를 쓰는 예제<ul><li>각각 크기가 다른 문자열을 담고 있음</ul></ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="k">struct</span> <span class="n">iovec</span> <span class="n">iov</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
    <span class="kt">ssize_t</span> <span class="n">nr</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

    <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">"aaa"</span><span class="p">,</span>
        <span class="s">"bbbb"</span><span class="p">,</span>
        <span class="s">"cccccc"</span>
    <span class="p">};</span>

    <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"buccaneer.txt"</span><span class="p">,</span> <span class="n">O_WRONLY</span> <span class="o">|</span> <span class="n">OCREAT</span> <span class="o">|</span> <span class="n">O_TRUNC</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1">// error</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1">// 세 iovec 구조체 값을 채운다</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">iov</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">iov_base</span> <span class="o">=</span> <span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">iov</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">iov_len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 단 한번의 호출로 세 iovec 내용을 모두 쓴다</span>
    <span class="n">nr</span> <span class="o">=</span> <span class="n">writev</span> <span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nr</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="p">)</span>
        <span class="c1">//error</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"wrote %d bytes</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">nr</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">))</span>
        <span class="c1">//error</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">readv()</code>예제</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/stat.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/uio.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span>
<span class="p">{</span>
        <span class="kt">char</span> <span class="n">foo</span><span class="p">[</span><span class="mi">48</span><span class="p">],</span> <span class="n">bar</span><span class="p">[</span><span class="mi">51</span><span class="p">],</span> <span class="n">baz</span><span class="p">[</span><span class="mi">49</span><span class="p">];</span>
        <span class="k">struct</span> <span class="n">iovec</span> <span class="n">iov</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
        <span class="kt">ssize_t</span> <span class="n">nr</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

        <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span> <span class="p">(</span><span class="s">"buccaneer.txt"</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">==</span> <span class="err">−</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">perror</span> <span class="p">(</span><span class="s">"open"</span><span class="p">);</span>
                <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* set up our iovec structures */</span>
        <span class="n">iov</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_base</span> <span class="o">=</span> <span class="n">foo</span><span class="p">;</span>
        <span class="n">iov</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_len</span> <span class="o">=</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">foo</span><span class="p">);</span>
        <span class="n">iov</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">iov_base</span> <span class="o">=</span> <span class="n">bar</span><span class="p">;</span>
        <span class="n">iov</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">iov_len</span> <span class="o">=</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">bar</span><span class="p">);</span>
        <span class="n">iov</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">iov_base</span> <span class="o">=</span> <span class="n">baz</span><span class="p">;</span>
        <span class="n">iov</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">iov_len</span> <span class="o">=</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">baz</span><span class="p">);</span>

        <span class="cm">/* read into the structures with a single call */</span>
        <span class="n">nr</span> <span class="o">=</span> <span class="n">readv</span> <span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nr</span> <span class="o">==</span> <span class="err">−</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">perror</span> <span class="p">(</span><span class="s">"readv"</span><span class="p">);</span>
                <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                <span class="n">printf</span> <span class="p">(</span><span class="s">"%d: %s"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">iov</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">iov_base</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">close</span> <span class="p">(</span><span class="n">fd</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">perror</span> <span class="p">(</span><span class="s">"close"</span><span class="p">);</span>
                <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>구현</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/uio.h&gt;</span><span class="cp">
</span>
<span class="kt">ssize_t</span> <span class="nf">naive_writev</span> <span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">ssize_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">ssize_t</span> <span class="n">nr</span><span class="p">;</span>

                <span class="n">errno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">nr</span> <span class="o">=</span> <span class="n">write</span> <span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">iov</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">iov_base</span><span class="p">,</span> <span class="n">iov</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">iov_len</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">nr</span> <span class="o">==</span> <span class="err">−</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EINTR</span><span class="p">)</span>
                                <span class="k">continue</span><span class="p">;</span>
                        <span class="n">ret</span> <span class="o">=</span> <span class="err">−</span><span class="mi">1</span><span class="p">;</span>
                        <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">ret</span> <span class="o">+=</span> <span class="n">nr</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>readv()와 writev()는 사용자 영역에서 <strong>단순 루프를 사용해서 구현할 수 있음</strong>!<li>사실 리눅스 커널 내부의 모든 입출력은 벡터 입출력이다.<ul><li>read, write 구현 역시 하나짜리 세그먼트를 가지는 벡터 입출력으로 구현되어 있음.</ul></ul><h1 id="42-epoll">4.2 epoll</h1><ul><li>poll과 select 의 한계에 대해서 인지하면서 커널 2.6버전에서는 <code class="language-plaintext highlighter-rouge">epoll</code>(event poll) 이라는 기능이 추가되었음<li><code class="language-plaintext highlighter-rouge">poll과 select</code><ul><li>실행할 때마다 전체 fd를 요구함<ul><li>→ 커널은 검사해야 할 모든 파일 리스트를 다 살펴봐야함.<li>→ fd 리스트의 크기가 수백 ~ 수천까지 커지면 병목현상이 발생</ul></ul><li><code class="language-plaintext highlighter-rouge">epoll</code>은 실제로 검사하는 부분과 검사할 fd를 등록하는 부분을 분리해서 위의 문제를 해결함<li><code class="language-plaintext highlighter-rouge">epoll</code>은 세 가지 System call로 동작함<ol><li>epoll 컨텍스트를 초기화<li>검사해야 할 fd를 epoll 컨텍스트에 등록하거나 삭제함<li>실제 이벤트를 기다리도록 동작</ol></ul><h2 id="421-새로운-epoll-인스턴스-생성하기">4.2.1 새로운 epoll 인스턴스 생성하기</h2><ul><li>epoll 컨텍스트는 <code class="language-plaintext highlighter-rouge">epoll_create1()</code>을 통해서 생성됨</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;sys/epoll.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">epoll_create1</span> <span class="p">(</span><span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>

<span class="cm">/* deprecated. use epoll_create1() in new code. */</span>
<span class="kt">int</span> <span class="nf">epoll_create</span> <span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>호출이 성공하면 새로운 epoll 인스턴스를 생성하고 그 인스턴스와 연관된 fd (epoll fd) 를 반환한다.<ul><li><em>요 fd는 실제 파일과는 아무런 관계가 없고 epoll 기능을 사용하는 다음 호출에 사용되는 핸들일 뿐임.</em></ul><li><code class="language-plaintext highlighter-rouge">flag</code> 인자는 epoll 동작을 조정하기 위한 것<ul><li><code class="language-plaintext highlighter-rouge">0</code>을 쓰면 size 인자가 없어졌다는 점을 빼면 <code class="language-plaintext highlighter-rouge">epoll_create()</code>과 동일함!<ul><li>epoll_fd 의 크기정보를 전달했었음</ul><li>현재는 <code class="language-plaintext highlighter-rouge">EPOLL_CLOSEXEC</code> 만 유효함<li>새 프로세스가 실행될 때 이 파일을 자동적으로 닫아준다.</ul><li><p>에러가 발생하면 -1을 반환, errno를 설정</p><ul><li><code class="language-plaintext highlighter-rouge">EINVAL</code><ul><li>잘못된 flags 인자</ul><li><code class="language-plaintext highlighter-rouge">EMFILE</code><ul><li>사용자의 최대 파일 초과</ul><li><code class="language-plaintext highlighter-rouge">ENFILE</code><ul><li>시스템의 최대 파일 초과</ul><li><code class="language-plaintext highlighter-rouge">ENOMEM</code><ul><li>메모리 부족</ul></ul><li><p>사용예제</p><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">epfd</span><span class="p">;</span>

<span class="n">epfd</span> <span class="o">=</span> <span class="n">epoll_create1</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">epfd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">perror</span> <span class="p">(</span><span class="s">"epoll_create1"</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>epoll_create1()에서 반환하는 fd는 폴링이 끝난 뒤에 반드시 close()로 닫아줘야한다.</ul></ul><h2 id="422-epoll-제어">4.2.2 epoll 제어</h2><ul><li><p><code class="language-plaintext highlighter-rouge">epoll_ctl()</code> 시스템 콜은 주어진 epoll 컨텍스트에 fd를 추가하거나 삭제할 때 사용한다.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;sys/epoll.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">epoll_ctl</span> <span class="p">(</span><span class="kt">int</span> <span class="n">epfd</span><span class="p">,</span>
               <span class="kt">int</span> <span class="n">op</span><span class="p">,</span>
               <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span>
               <span class="k">struct</span> <span class="n">epoll_event</span> <span class="o">*</span><span class="n">event</span><span class="p">);</span>
</pre></table></code></div></div><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">epoll_event</span> <span class="p">{</span>
        <span class="n">__u32</span> <span class="n">events</span><span class="p">;</span>  <span class="cm">/* events */</span>
        <span class="k">union</span> <span class="p">{</span>
                <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
                <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
                <span class="n">__u32</span> <span class="n">u32</span><span class="p">;</span>
                <span class="n">__u64</span> <span class="n">u64</span><span class="p">;</span>
        <span class="p">}</span> <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><li>epoll_ctl() 호출이 성공하면 해당 epoll 인스턴스는 epfd 파일 디스크립터와 연결된다.<li><code class="language-plaintext highlighter-rouge">epfd</code><ul><li>이전에 epoll_create1() 로 생성한 epoll fd</ul><li><code class="language-plaintext highlighter-rouge">fd</code><ul><li>등록할 fd</ul><li><code class="language-plaintext highlighter-rouge">op</code> 인자는 fd가 가리키는 파일에 대한 작업을 명시한다.<ul><li>어떤 변경을 할지 결정하는 값<li><code class="language-plaintext highlighter-rouge">EPOLL_CTL_ADD</code><ul><li>epfd와 연관된 epoll 인스턴스가 fd와 연관된 파일을 감시하도록 <code class="language-plaintext highlighter-rouge">추가</code>하며, 각 이벤트는 event 인자로 정의한다.</ul><li><code class="language-plaintext highlighter-rouge">EPOLL_CTL_DEL</code><ul><li>epfd와 연관된 epoll 인스턴스에 fd를 감시하지 않도록 <code class="language-plaintext highlighter-rouge">삭제</code>한다.</ul><li><code class="language-plaintext highlighter-rouge">EPOLL_CTL_MOD</code><ul><li>기존에 감시하고 있는 fd에 대한 이벤트를 event에 명시된 내용으로 <code class="language-plaintext highlighter-rouge">갱신</code>한다.</ul></ul><li><code class="language-plaintext highlighter-rouge">event</code> 인자는 그 작업의 동작에 대한 설명을 담고 있다.<ul><li>이벤트 유형</ul><li>epoll_event 구조체의 events 필드는 주어진 fd에서 감시할 이벤트의 목록을 담고 있음<ul><li>여러가지 이벤트를 OR로 묶을 수 있다.<div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">enum</span> <span class="n">Events</span>
<span class="p">{</span>
 <span class="n">EPOLLIN</span><span class="p">,</span>   <span class="c1">//수신할 데이터가 있다.</span>
 <span class="n">EPOLLOUT</span><span class="p">,</span>  <span class="c1">//송신 가능하다.</span>
 <span class="n">EPOLLPRI</span><span class="p">,</span>  <span class="c1">//중요한 데이터(OOB)가 발생.</span>
 <span class="n">EPOLLRDHUD</span><span class="p">,</span><span class="c1">//연결 종료 or Half-close 발생</span>
 <span class="n">EPOLLERR</span><span class="p">,</span>  <span class="c1">//에러 발생</span>
 <span class="n">EPOLLET</span><span class="p">,</span>   <span class="c1">//엣지 트리거 방식으로 설정</span>
 <span class="n">EPOLLONESHOT</span><span class="p">,</span> <span class="c1">//한번만 이벤트 받음</span>
<span class="p">}</span>
</pre></table></code></div></div></ul><li>epoll_event 구조체의 <code class="language-plaintext highlighter-rouge">data 필드</code>는 사용자 데이터를 위한 필드이다.<ul><li>이 필드에 담긴 내용은 요청한 이벤트가 발생해서 사용자에게 반환될 때 함께 반환됨.<li>일반적인 사용 예<ul><li>event.data.fd를 fd로 채워서 이벤트가 발생했을 때 어떤 fd를 들여다 봐야 하는지 확인하는 용도</ul></ul><li>성공 시 0을 반환하고 실패 시 -1을 반환, errno 설정<li><p>예제 코드</p><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">event</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

<span class="n">event</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span> <span class="cm">/* return the fd to us later (from epoll_wait) */</span>
<span class="n">event</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">EPOLLIN</span> <span class="o">|</span> <span class="n">EPOLLOUT</span><span class="p">;</span>

<span class="n">ret</span> <span class="o">=</span> <span class="n">epoll_ctl</span> <span class="p">(</span><span class="n">epfd</span><span class="p">,</span> <span class="n">EPOLL_CTL_ADD</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
        <span class="n">perror</span> <span class="p">(</span><span class="s">"epoll_ctl"</span><span class="p">);</span>
</pre></table></code></div></div><li><p>epfd와 연관된 fd에 설정된 기존 구독 이벤트를 변경하려면 아래와 같이 작성하면 됨</p><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">event</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

<span class="n">event</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span> <span class="cm">/* return the fd to us later */</span>
<span class="n">event</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">EPOLLIN</span><span class="p">;</span>

<span class="n">ret</span> <span class="o">=</span> <span class="n">epoll_ctl</span> <span class="p">(</span><span class="n">epfd</span><span class="p">,</span> <span class="n">EPOLL_CTL_MOD</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
        <span class="n">perror</span> <span class="p">(</span><span class="s">"epoll_ctl"</span><span class="p">);</span>
</pre></table></code></div></div><li><p>반대로 epoll 인스턴스 epfd에 등록된 fd에 연관된 기존 이벤트를 삭제하려면 아래와 같이!</p><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">event</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

<span class="n">ret</span> <span class="o">=</span> <span class="n">epoll_ctl</span> <span class="p">(</span><span class="n">epfd</span><span class="p">,</span> <span class="n">EPOLL_CTL_DEL</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
        <span class="n">perror</span> <span class="p">(</span><span class="s">"epoll_ctl"</span><span class="p">);</span>
</pre></table></code></div></div><li>op 값이 <code class="language-plaintext highlighter-rouge">EPOLL_CTL_DEL</code>인 경우 이벤트 마스크가 없기 때문에 <code class="language-plaintext highlighter-rouge">event</code> 값이 <code class="language-plaintext highlighter-rouge">NULL</code>이 될 수도 있음.<ul><li>하지만, 호환성 문제 떄문에 유효한 포인터를 넘겨야함.</ul></ul><h2 id="423-epoll로-이벤트-기다리기">4.2.3 epoll로 이벤트 기다리기</h2><ul><li><code class="language-plaintext highlighter-rouge">epoll_wait()</code> 시스템 콜은 <strong>epoll 인스턴스와 연관된 fd에 대한 이벤트를 기다린다</strong>.</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;sys/epoll.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">epoll_wait</span><span class="p">(</span> <span class="kt">int</span> <span class="n">efpd</span><span class="p">,</span>                  <span class="c1">//epoll_fd</span>
                <span class="k">struct</span> <span class="n">epoll_event</span><span class="o">*</span> <span class="n">event</span><span class="p">,</span> <span class="c1">//event 버퍼의 주소</span>
                <span class="kt">int</span> <span class="n">maxevents</span><span class="p">,</span>             <span class="c1">//버퍼에 들어갈 수 있는 구조체 최대 개수</span>
                <span class="kt">int</span> <span class="n">timeout</span>                <span class="c1">//select의 timeout과 동일 단위는 1/1000</span>
              <span class="p">);</span>
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">epoll_wait</code> 를 호출하면 timeout 밀리 초 동안 epoll 인스턴스인 epfd와 연관된 파일의 이벤트를 기다린다.<li>성공할 경우 <code class="language-plaintext highlighter-rouge">events</code>에는 발생한 해당 이벤트 <em>(파일이 읽어나 쓰기가 가능한 상태인지를 나타내는 epoll_event 구조체에 대한 포인터)</em> 가 기록된다. 발생한 이벤트 개수를 반환<ul><li>events의 <code class="language-plaintext highlighter-rouge">data 필드</code>에는 사용자가 <code class="language-plaintext highlighter-rouge">epoll_ctl()</code> 을 호출하기 전에 설정한 값이 담겨 있다.<blockquote><p><strong>따라서 모든 fd에 대해 순회하면서 체크할 필요가 없음! 이벤트가 있는 fd들이 배열에 담겨오고 그 개수를 알 수 있으니 꼭 필요한 event 만 순회하면서 처리할 수 있다는 장점!</strong></p></blockquote></ul><li>에러가 발생할 경우 -1을 반환하고 errno 를 설정<li><code class="language-plaintext highlighter-rouge">timeout</code><ul><li>0이면 epoll_wait()는 이벤트가 발생하지 않아도 즉시 0을 반환함.<li>-1이면 이벤트가 발생할 때까지 해당 호출은 반환되지 않음</ul><li>예제</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="cp">#define MAX_EVENTS    64
</span>
<span class="k">struct</span> <span class="n">epoll_event</span> <span class="o">*</span><span class="n">events</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">nr_events</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">epfd</span><span class="p">;</span>

<span class="n">events</span> <span class="o">=</span> <span class="n">malloc</span> <span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">epoll_event</span><span class="p">)</span> <span class="o">*</span> <span class="n">MAX_EVENTS</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">events</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span> <span class="p">(</span><span class="s">"malloc"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">nr_events</span> <span class="o">=</span> <span class="n">epoll_wait</span> <span class="p">(</span><span class="n">epfd</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">MAX_EVENTS</span><span class="p">,</span> <span class="err">−</span><span class="mi">1</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">nr_events</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span> <span class="p">(</span><span class="s">"epoll_wait"</span><span class="p">);</span>
        <span class="n">free</span> <span class="p">(</span><span class="n">events</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_events</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span> <span class="p">(</span><span class="s">"event=%ld on fd=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                <span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">events</span><span class="p">,</span>
                <span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span><span class="p">);</span>
				<span class="cm">/*
         * We now can, per events[i].events, operate on
         * events[i].data.fd without blocking.
         */</span>
<span class="p">}</span>

<span class="n">free</span> <span class="p">(</span><span class="n">events</span><span class="p">);</span>
</pre></table></code></div></div><h2 id="424-에지-트리거와-레벨-트리거">4.2.4 에지 트리거와 레벨 트리거</h2><p><img data-proofer-ignore data-src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1b2027c5-7d99-4cff-88a6-2e7918e8507f/Untitled.png" alt="Untitled" /></p><ul><li><code class="language-plaintext highlighter-rouge">epoll_ctl()</code>로 전달하는 event 인자의 events 필드를 <code class="language-plaintext highlighter-rouge">EPOLLET</code>로 설정하면 fd에 대한 이벤트 모니터가 <code class="language-plaintext highlighter-rouge">레벨 트리거</code>가 아닌 <code class="language-plaintext highlighter-rouge">에지 트리거</code>로 동작한다.<li><strong>유닉스 파이프 통신 입출력 예시</strong><ol><li><code class="language-plaintext highlighter-rouge">출력</code>하는 쪽에서 파이프에 1KB만큼의 데이터를 씀<li><code class="language-plaintext highlighter-rouge">입력</code>을 받는 쪽에서는 파이프에 대해서 <code class="language-plaintext highlighter-rouge">epoll_wait()</code>를 수행하고 파이프에 데이터가 들어와서 읽을 수 있는 상태가 되기를 기다림<ul><li><strong><code class="language-plaintext highlighter-rouge">레벨 트리거</code>일 경우</strong><ul><li>2단계의 <code class="language-plaintext highlighter-rouge">epoll_wait()</code> <strong>호출은 즉시 반환</strong>하며 파이프가 읽을 준비가 되었음을 알려줌</ul><li><strong><code class="language-plaintext highlighter-rouge">에지 트리거</code>일 경우</strong><ul><li><strong>1단계가 완료될 때까지 호출이 반환되지 않음</strong>.<li>즉, epoll_wait()를 호출하는 시점에 파이프를 읽을 수 있는 상황이더라도 파이프에 데이터가 들어오기 전까지는 결과 반환 안함.</ul></ul></ol><li>기본 동작 방식은 레벨 트리거<ul><li>poll()과 select()의 동작방식도 동일</ul></ul><h1 id="43-메모리에-파일-맵핑하기">4.3 메모리에 파일 맵핑하기</h1><ul><li>리눅스 커널은 표준 파일 입출력의 대안으로 <strong>애플리케이션이 파일을 메모리에 맵핑할 수 있는 인터페이스를 제공</strong>한다.<ul><li>메모리 주소와 파일의 단어가 일대일 대응이 된다는 것을 의미<li>→ 개발자가 메모리를 통해 파일에 직접 접근이 가능함.<ul><li>→ 메모리 주소에 직접 쓰는 것만으로 디스크에 있는 파일에 기록할 수 있음</ul></ul></ul><h2 id="431-mmap">4.3.1 mmap()</h2><ul><li><code class="language-plaintext highlighter-rouge">mmap()</code>을 호출하면 <strong>fd가 가리키는 파일의 offset 위치에서 len 바이트만큼 메모리에 맵핑하도록 커널에 요청</strong>한다.</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;sys/mman.h&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="o">*</span> <span class="nf">mmap</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
             <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
             <span class="kt">int</span> <span class="n">prot</span><span class="p">,</span>
             <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
             <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span>
             <span class="kt">off_t</span> <span class="n">offset</span><span class="p">);</span>
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">addr</code><ul><li>addr가 포함되면 메모리에서 해당 주소를 선호한다고 커널에 알려줌<li>그저 힌트일 뿐이며 대부분 <code class="language-plaintext highlighter-rouge">0</code>을 넘겨줌</ul><li><code class="language-plaintext highlighter-rouge">len</code><ul><li>fd 가 가리키는 파일의 <code class="language-plaintext highlighter-rouge">offset</code> 위치에서 <code class="language-plaintext highlighter-rouge">len</code> 바이트만큼 메모리에 맵핑하도록 커널에 요청함.</ul><li><code class="language-plaintext highlighter-rouge">prot</code><ul><li>접근권한을 지정<li>맵핑에 원하는 메모리 보호 정책을 명시 <code class="language-plaintext highlighter-rouge">PROT_NONE</code>: 접근 불가 <code class="language-plaintext highlighter-rouge">PROT_READ</code>: 읽기 가능 <code class="language-plaintext highlighter-rouge">PROT_WRITE</code>: 쓰기 가능 <code class="language-plaintext highlighter-rouge">PROT_EXEC</code>: 실행 가능</ul><li><code class="language-plaintext highlighter-rouge">flag</code><ul><li>맵핑의 유형과 그 동작에 관한 몇 가지 요소를 명시<li><code class="language-plaintext highlighter-rouge">MAP_FIXED</code> : mmap()의 addr 인자를 힌트가 아니라 요구사항으로 취급하도록 함<li><code class="language-plaintext highlighter-rouge">MAP_PRIVATE</code> : 맵핑이 공유되지 않음을 명시. 파일은 copy-on-write 로 맵핑됨.<li><code class="language-plaintext highlighter-rouge">MAP_SHARED</code> : 같은 파일을 맵핑한 모든 프로세스와 맵핑을 공유<li><code class="language-plaintext highlighter-rouge">MAP_SHARED</code>와 <code class="language-plaintext highlighter-rouge">MAP_PRIVATE</code>를 함께 지정하면 안됨.</ul><li>반환<ul><li>메모리 맵핑의 실제 시작 주소를 반환한다.</ul><li>fd를 맵핑하면 해당 파일의 참조 카운터가 증가한다. → <strong>따라서 파일을 맵핑한 후에 fd를 닫더라도 프로세스는 여전히 맵핑된 주소에 접근할 수 있다.</strong><li><p>예시</p><ul><li>fd가 가리키는 파일의 첫 바이트부터 len 바이트까지를 읽기 전용으로 맵핑한다.</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">mmap</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">PROT_READ</span><span class="p">,</span> <span class="n">MAP_SHARED</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">MAP_FAILED</span><span class="p">)</span>
        <span class="n">perror</span> <span class="p">(</span><span class="s">"mmap"</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>mmap() 에 전달하는 인자가 맵핑하는 과정 <img data-proofer-ignore data-src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/75534a2f-94ec-405c-8e34-5fff1e8e5ef9/Untitled.png" alt="Untitled" /></ul></ul><h3 id="페이지-크기">페이지 크기</h3><ul><li><code class="language-plaintext highlighter-rouge">페이지</code>는 메모리 관리 유닛 (MMU)에서 사용하는 최소 단위이다.<ul><li>별도의 접근 권한과 동작 방식을 따르는 가장 작은 메모리 단위라고 할 수 있음.<li>메모리 맵핑을 구성하는 블록이자 프로세스 주소 공간을 구성하는 블록</ul><li><p><code class="language-plaintext highlighter-rouge">mmap()</code> 시스템 콜은 페이지를 다루기 때문에 <code class="language-plaintext highlighter-rouge">addr</code>과 <code class="language-plaintext highlighter-rouge">offset</code> 인자는 페이지 크기 단위(<strong>페이지 크기의 정수배)</strong>로 정렬되어야 한다.</p><ul><li>만약 len인자가 페이지 크기 단위로 정렬되지 않았다면 <em>다음 크기의 페이지 정수배로 확장됨</em><li>마지막 유효 바이트와 맵핑의 끝 사이에 추가된 메모리는 0으로 채워짐</ul><li><p>페이지 크기를 얻을 수 있는 표준 메서드는 <code class="language-plaintext highlighter-rouge">sysconf()</code>이다.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span>
<span class="kt">long</span> <span class="nf">sysconf</span> <span class="p">(</span><span class="kt">int</span> <span class="n">name</span><span class="p">);</span>
</pre></table></code></div></div><li><p>POSIX는 페이지 크기를 바이트 단위로 <code class="language-plaintext highlighter-rouge">_SC_PAGESIZE</code> (or <code class="language-plaintext highlighter-rouge">_SC_PAGE_SIZE</code>) 로 정의함.</p><ul><li><strong>런타임의 페이지 크기</strong>를 구하는 방법은 아래와 같다.</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">long</span> <span class="n">page_size</span> <span class="o">=</span> <span class="n">sysconf</span> <span class="p">(</span><span class="n">_SC_PAGESIZE</span><span class="p">);</span>
</pre></table></code></div></div><li><p>리눅스는 바이트 단위의 페이지 크기를 반환하는 <code class="language-plaintext highlighter-rouge">getpagesize()</code>를 제공함</p><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">getpagesize</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</pre></table></code></div></div><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">page_size</span> <span class="o">=</span> <span class="n">getpagesize</span> <span class="p">();</span>
</pre></table></code></div></div><li>PAGE_SIZE 매크로를 통해서도 페이지 크기를 구할 수 있는데, 런타임이 아닌 컴파일 시점에 시스템의 페이지 크기를 가져온다.<div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">page_size</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
</pre></table></code></div></div></ul><h3 id="반환값과-에러">반환값과 에러</h3><ul><li><code class="language-plaintext highlighter-rouge">mmap()</code> 호출이 성공하면 맵핑된 주소를 반환한다.<li>실패하면 <code class="language-plaintext highlighter-rouge">MAP_FAILED</code>(-1) 를 반환하고 errno를 설정한다.<li><strong>절대 0을 반환하지 않음</strong>.</ul><h3 id="관련-시그널">관련 시그널</h3><ul><li><code class="language-plaintext highlighter-rouge">SIGBUS</code><ul><li>프로세스가 더 이상 유효하지 않은 맵핑 영역에 접근하려고 할 때 발생함.<li>맵핑된 후에 파일이 잘렸을 경우에 이 시그널이 발생함.</ul><li><code class="language-plaintext highlighter-rouge">SIGSEGV</code><ul><li>프로세스가 읽기 전용으로 맵핑된 영역에 쓰려고 할 때 발생</ul></ul><h2 id="432-munmap">4.3.2 munmap()</h2><ul><li><code class="language-plaintext highlighter-rouge">mmap()</code>으로 생성한 맵핑을 해제하기 위한 <code class="language-plaintext highlighter-rouge">munmap()</code> 시스템 콜을 제공함.</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;sys/mman.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">munmap</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>페이지 크기로 정렬된 <code class="language-plaintext highlighter-rouge">addr</code>에서 시작해서 <code class="language-plaintext highlighter-rouge">len</code> 바이트만큼 이어지는 프로세스 주소 공간에 존재하는 페이지를 포함하는 맵핑을 해제함.<ul><li>맵핑 해제하고 다시 접근하면 <code class="language-plaintext highlighter-rouge">SIGSEGV</code> 시그널이 발생함.</ul><li>성공 시 0을 반환, 실패 시 -1을 반환하고 errno 설정<li>예제<ul><li><code class="language-plaintext highlighter-rouge">[addr, addr+len]</code> 사이에 포함된 페이지를 담고 있는 메모리 영역에 대한 맵핑을 해제함.<div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span><span class="n">munmap</span> <span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="o">==</span> <span class="err">−</span><span class="mi">1</span><span class="p">)</span>
      <span class="n">perror</span> <span class="p">(</span><span class="s">"munmap"</span><span class="p">);</span>
</pre></table></code></div></div></ul></ul><h2 id="433-맵핑-예제">4.3.3 맵핑 예제</h2><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/stat.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/mman.h&gt;</span><span class="cp">
</span>
<span class="c1">// 인자로 파일 이름을 받음</span>
<span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">stat</span> <span class="n">sb</span><span class="p">;</span>
        <span class="kt">off_t</span> <span class="n">len</span><span class="p">;</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">fprintf</span> <span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"usage: %s &lt;file&gt;</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
                <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span> <span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">O_RDONLY</span><span class="p">);</span>      <span class="c1">// 인자로 넘겨받은 파일을 연다</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">==</span> <span class="err">−</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">perror</span> <span class="p">(</span><span class="s">"open"</span><span class="p">);</span>
                <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">fstat</span> <span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sb</span><span class="p">)</span> <span class="o">==</span> <span class="err">−</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>        <span class="c1">// fstat : 주어진 파일에 대한 정보 반환</span>
                <span class="n">perror</span> <span class="p">(</span><span class="s">"fstat"</span><span class="p">);</span>
                <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISREG</span> <span class="p">(</span><span class="n">sb</span><span class="p">.</span><span class="n">st_mode</span><span class="p">))</span> <span class="p">{</span>        <span class="c1">// 주어진 파일이 디바이스 파일이나 디렉터리가 아닌 일반 파일인지 점검</span>
                <span class="n">fprintf</span> <span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"%s is not a file</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
                <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">p</span> <span class="o">=</span> <span class="n">mmap</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sb</span><span class="p">.</span><span class="n">st_size</span><span class="p">,</span> <span class="n">PROT_READ</span><span class="p">,</span> <span class="n">MAP_SHARED</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// 맵핑 수행</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">MAP_FAILED</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">perror</span> <span class="p">(</span><span class="s">"mmap"</span><span class="p">);</span>
                <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">close</span> <span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="o">==</span> <span class="err">−</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">perror</span> <span class="p">(</span><span class="s">"close"</span><span class="p">);</span>
                <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="n">sb</span><span class="p">.</span><span class="n">st_size</span><span class="p">;</span> <span class="n">len</span><span class="o">++</span><span class="p">)</span>
                <span class="n">putchar</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">len</span><span class="p">]);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">munmap</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">sb</span><span class="p">.</span><span class="n">st_size</span><span class="p">)</span> <span class="o">==</span> <span class="err">−</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">perror</span> <span class="p">(</span><span class="s">"munmap"</span><span class="p">);</span>
                <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="434-mmap의-장점">4.3.4 mmap()의 장점</h2><ul><li><code class="language-plaintext highlighter-rouge">read()</code>와 <code class="language-plaintext highlighter-rouge">write()</code> 시스템 콜을 사용하는 것보다 <code class="language-plaintext highlighter-rouge">mmap()</code>을 이용해서 파일을 조작하는 것이 좀 더 <strong>유용하다</strong>.</ul><ol><li>read, write 시스템 콜 사용할 때 발생하는 불필요한 복사를 방지할 수 있음.<ul><li><em>사용자 영역의 버퍼로 데이터를 읽고 써야 하기 때문에 추가적인 복사가 발생함.</em></ul><li><em>(잠재적인 <strong>페이지 폴트</strong> 가능성을 제외하면)</em> 시스템 콜 호출이나 컨텍스트 스위칭 오버헤드가 발생하지 않음<li>여러 개의 프로세스가 같은 객체를 메모리에 맵핑한다면 데이터는 모든 프로세스 사이에서 공유된다.<li><code class="language-plaintext highlighter-rouge">lseek()</code> 같은 시스템 콜을 사용하지 않고도 맵핑영역 탐색 가능</ol><h2 id="435-mmap의-단점">4.3.5 mmap()의 단점</h2><ol><li>메모리 맵핑은 항상 페이지 크기의 정수배만 가능하다.<li>메모리 맵핑은 반드시 프로세스의 주소 공간에 딱 맞아야한다.<ul><li>다양한 사이즈의 맵핑이 있다면 <code class="language-plaintext highlighter-rouge">파편화</code>가 일어남</ul><li>메모리 맵핑과 관련 자료구조를 커널 내부에서 생성, 유지하는데 오버헤드가 발생한다.<ul><li>이중 복사 제거 방법으로 방지할 수 있음<blockquote><p><em>읽기 요청마다 표준 입출력 버퍼를 가리키는 포인터를 반환하는 대체 구현을 통해 데이터를 표준 입출력 버퍼에서 직접 읽을 수 있음 → 불필요한 복사 피함</em></p></blockquote></ul></ol><h2 id="436-맵핑-크기-변경하기">4.3.6 맵핑 크기 변경하기</h2><ul><li>리눅스는 주어진 메모리 맵핑 영역의 크기를 확장하거나 축소하기 위한 <code class="language-plaintext highlighter-rouge">mremap()</code> 시스템 콜을 제공함.</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="cp">#define _GNU_SOURCE
</span>
<span class="cp">#include</span> <span class="cpf">&lt;sys/mman.h&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="o">*</span> <span class="nf">mremap</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">old_size</span><span class="p">,</span>
               <span class="kt">size_t</span> <span class="n">new_size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>mrepap()은 <code class="language-plaintext highlighter-rouge">[addr, addr + old_size)</code> 에 맵핑된 영역을 <code class="language-plaintext highlighter-rouge">new_size</code> 만큼의 크기로 변경한다.<li><code class="language-plaintext highlighter-rouge">flag</code><ul><li>0<li><code class="language-plaintext highlighter-rouge">MREMAP_MAYMOVE</code> : 크기 변경 요청을 수행하는데 필요하다면 맵핑의 위치를 이동해도 괜찮다고 커널에 알려준다.<ul><li><em>맵핑 위치를 이동시킬 수 있다면 큰 크기 변경 요청이 성공할 가능성이 높아짐</em></ul></ul><li>성공 시 조정된 메모리 맵핑의 시작 주소를 반환함.<li>실패할 경우 <code class="language-plaintext highlighter-rouge">MAP_FAILED</code> 를 반환하며 errno 를 설정<li><p>예제</p><ul><li>glibc 같은 라이브러리는 malloc()으로 할당한 메모리의 크기를 변경하기 위한 realloc()을 효율적으로 구현하기 위해 <code class="language-plaintext highlighter-rouge">mremap()</code>을 자주 사용함</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="o">*</span> <span class="nf">realloc</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">size_t</span> <span class="n">old_size</span> <span class="o">=</span> <span class="n">look_up_mapping_size</span> <span class="p">(</span><span class="n">addr</span><span class="p">);</span>
        <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

        <span class="n">p</span> <span class="o">=</span> <span class="n">mremap</span> <span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">old_size</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">MREMAP_MAYMOVE</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">MAP_FAILED</span><span class="p">)</span>
                <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div></ul><h3 id="437-맵핑의-보호-모드-변경하기">4.3.7 맵핑의 보호 모드 변경하기</h3><ul><li>POSIX는 기존 메모리 영역에 대한 접근 권한을 변경할 수 있는 <code class="language-plaintext highlighter-rouge">mprotect()</code> 인터페이스를 저으히함</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;sys/mman.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">mprotect</span> <span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
              <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
              <span class="kt">int</span> <span class="n">prot</span><span class="p">);</span>
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">[addr, addr+len)</code> 영역내에 포함된 메모리 페이지의 보호 모드를 변경한다.<li><code class="language-plaintext highlighter-rouge">prot</code><ul><li>mmap()에 사용한 prot 와 같은 값을 사용할 수 있다.<li>즉, 메모리 영역이 읽기가 가능한 상태에서 prot로 <code class="language-plaintext highlighter-rouge">PROT_WRITE</code>를 설정한다면 쓰기만 가능해짐!</ul><li>어떤 시스템에서는 <code class="language-plaintext highlighter-rouge">mmap()</code>으로 생성한 메모리 맵핑에 대해서만 <code class="language-plaintext highlighter-rouge">mprotect()</code>를 쓸 수 있지만, 리눅스에서는 어떤 메모리 영역에도 사용할 수 있다.<li>성공 시 0반환, 실패 시 -1 반환하고 errno 설정</ul><h2 id="438-파일과-맵핑의-동기화">4.3.8 파일과 맵핑의 동기화</h2><ul><li>POSIX 는 2장에서 살펴본 <code class="language-plaintext highlighter-rouge">fsync()</code> 시스템 콜의 메모리 맵핑 버전인 <code class="language-plaintext highlighter-rouge">msync()</code>를 제공한다.</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;sys/mman.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">msync</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">msync()</code>는 mmap()으로 맵핑된 파일에 대한 변경 내용을 디스크에 기록하여 파일과 맵핑을 동기화한다.<ul><li>구체적으로 살펴보면 메모리 주소 addr에서부터 len 바이트 만큼 맵핑된 파일이나 파일 일부를 디스크로 동기화함.<li>이때 addr 값은 반드시 페이지 크기로 정렬되어야 한다. <em>보통은 mmap()에서 반환한 값을 사용함</em></ul><li><strong><em>msync()를 호출하지 않으면 맵핑이 해제되기 전까지는 맵핑된 메모리에 쓰여진 내용이 디스크로 반영된다는 보장을 할 수가 없다.</em></strong><ul><li>쓰기 과정 중에 갱신된 버퍼를 디스크에 쓰도록 큐에 밀어넣는 <code class="language-plaintext highlighter-rouge">write()</code>와는 동작방식이 다름</ul><li><code class="language-plaintext highlighter-rouge">flag</code><ul><li><code class="language-plaintext highlighter-rouge">MS_SYNC</code> : 디스크에 모든 페이지를 기록하기 전까지 msync()는 반환하지 않는다.<li><code class="language-plaintext highlighter-rouge">MS_ASYNC</code> : 비동기 방식으로 동기화한다.<li><code class="language-plaintext highlighter-rouge">MS_INVALIDATE</code> : 맵핑의 캐시 복사본을 모두 무효화한다.<li>OR로 명시할 수 있지만, <code class="language-plaintext highlighter-rouge">MS_SYNC</code>와 <code class="language-plaintext highlighter-rouge">MS_ASYNC</code> 중 하나는 반드시 해야함. (<em>둘을 함께하는 것은 안됨</em>)</ul><li>예제<ul><li><code class="language-plaintext highlighter-rouge">[addr, addr+len)</code> 영역에 맵핑된 파일을 디스크로 동기화한다.<li>fsync()에 비해서 10배 빠름 (메모리라서)<div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span><span class="n">msync</span> <span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">MS_ASYNC</span><span class="p">)</span> <span class="o">==</span> <span class="err">−</span><span class="mi">1</span><span class="p">)</span>
      <span class="n">perror</span> <span class="p">(</span><span class="s">"msync"</span><span class="p">);</span>
</pre></table></code></div></div></ul><li>성공하면 0 반환, 실패하면 -1반환하고 errno 설정</ul><h2 id="439-맵핑의-사용처-알려주기">4.3.9 맵핑의 사용처 알려주기</h2><ul><li>리눅스는 프로세스가 맵핑을 어떻게 사용할 것인지 커널에 알려주는 <code class="language-plaintext highlighter-rouge">madvise()</code> 시스템 콜을 제공한다.<li>커널이 이를 통해 얻는 <code class="language-plaintext highlighter-rouge">힌트</code>를 사용해서 <strong>최적화가 가능함</strong>. 부하가 걸리는 상황에서 필요한 캐시와 미리 읽기 방식을 확실히 보장할 수 있게 된다.</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;sys/mman.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">madvise</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
             <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
             <span class="kt">int</span> <span class="n">advice</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>addr 로 시작해서 len 바이트의 크기를 가지는 메모리 맵핑 내의 페이지와 관련된 동작 방식에 대한 힌트를 커널에 제공함.<li><code class="language-plaintext highlighter-rouge">len</code><ul><li>0 이라면 커널은 addr에서 시작하는 전체 맵핑에 힌트를 적용한다.</ul><li><code class="language-plaintext highlighter-rouge">advice</code><ul><li><code class="language-plaintext highlighter-rouge">MADV_NORMAL</code> : 이 메모리 영역에 대한 특별한 힌트를 제공하지 않는다.<li><code class="language-plaintext highlighter-rouge">MADV_RANDOM</code> : 이 영역의 페이지는 랜덤하게 접근한다.<li><code class="language-plaintext highlighter-rouge">MADV_SEQUENTIAL</code> : 이 영역의 페이지는 낮은 주소에서 높은 주소로 순차적으로 접근한다.<li><code class="language-plaintext highlighter-rouge">MADV_WILLNEED</code> : 이 영역의 페이지는 곧 접근한다.<li><code class="language-plaintext highlighter-rouge">MADV_DONTNEED</code> : 이 영역의 페이지는 당분간 접근하지 않는다.</ul><li><p>POSIX는 힌트에 대한 의미만 정의하고 있다. 리눅스 커널 2.6 버전 부터는 각 힌트에 대해 조금 다르게 대응한다.</p><li><p>madvise 예시</p><ul><li><code class="language-plaintext highlighter-rouge">[addr, addr + len)</code> 메모리 영역을 순차적으로 접근할 것이라고 커널에 알려줌</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

<span class="n">ret</span> <span class="o">=</span> <span class="n">madvise</span> <span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">MADV_SEQUENTIAL</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">perror</span> <span class="p">(</span><span class="s">"madvise"</span><span class="p">);</span>
</pre></table></code></div></div><li>성공하면 0을 반환, 실패 시 -1을 반환하고 errno 설정</ul><h1 id="44-일반-파일-입출력에-대한-힌트">4.4 일반 파일 입출력에 대한 힌트</h1><ul><li>위에서는 메모리 맵핑을 사용하는데 힌트를 제공하는 방법에 대해서 알아봤음.<li>4.4 에서는 <strong>커널에 일반적인 파일 입출력에 대한 힌트를 제공하는 방법</strong>에 대해서 알아본다.</ul><h2 id="441-posix_fadvise-시스템-콜">4.4.1 posix_fadvise() 시스템 콜</h2><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">posix_fadvise</span> <span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span>
                   <span class="kt">off_t</span> <span class="n">offset</span><span class="p">,</span>
                   <span class="kt">off_t</span> <span class="n">len</span><span class="p">,</span>
                   <span class="kt">int</span> <span class="n">advice</span><span class="p">);</span>
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">fd</code>의 <code class="language-plaintext highlighter-rouge">[offset, offset + len)</code> 범위에 대한 힌트를 커널에 제공한다.<li><code class="language-plaintext highlighter-rouge">len</code><ul><li>0이면 파일 전체인 [offset, 파일 길이] 에 적용된다.<ul><li>len과 offset을 0으로 넘기면 전체 파일에 대한 힌트제공</ul></ul><li><code class="language-plaintext highlighter-rouge">advise</code><ul><li>madvise와 유사함. 한 가지 설정만 가능하다.<li><code class="language-plaintext highlighter-rouge">POSIX_FADV_NORMAL</code> : 힌트 제공 안함<li><code class="language-plaintext highlighter-rouge">POSIX_FADV_RANDOM</code> : 데이터에 랜덤하게 접근<li><code class="language-plaintext highlighter-rouge">POSIX_FADV_SEQUENTIAL</code> : 낮은 주소에서 높은 주소로 순차적<li><code class="language-plaintext highlighter-rouge">POSIX_FADV_WILLNEED</code> : 곧 접근<li><code class="language-plaintext highlighter-rouge">POSIX_FADV_NOREUSE</code> : 한번만 접근<li><code class="language-plaintext highlighter-rouge">POSIX_FADV_DONTNEED</code> : 당분간 접근안함<li>madvise와 동일하게 커널이 이런 힌트에 대응하는 방법은 구현에 따라 다른다. (심지어는 커널 버전에 따라 다르게 동작함.)</ul><li><p>예제</p><ul><li>커널에게 fd가 가리키는 전체 파일에 랜덤하게 접근하겠다고 알려줌</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

<span class="n">ret</span> <span class="o">=</span> <span class="n">posix_fadvise</span> <span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">POSIX_FADV_RANDOM</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="err">−</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">perror</span> <span class="p">(</span><span class="s">"posix_fadvise"</span><span class="p">);</span>
</pre></table></code></div></div><li>성공하면 0을 반환, 실패하면 -1 반환하고 errno 설정</ul><h2 id="442-readahead-시스템-콜">4.4.2 readahead() 시스템 콜</h2><ul><li><code class="language-plaintext highlighter-rouge">POSIX_FADV_WILLNEED</code> 힌트와 동일한 동작 방식을 제공하기 위해 사용<li>리눅스 전용 인터페이스이다.</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="cp">#define _GNU_SOURCE
</span>
<span class="cp">#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
</span>
<span class="kt">ssize_t</span> <span class="nf">readahead</span> <span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span>
                   <span class="n">off64_t</span> <span class="n">offset</span><span class="p">,</span>
                   <span class="kt">size_t</span> <span class="n">count</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>fd가 가리키는 파일의 <code class="language-plaintext highlighter-rouge">[offset, offset+count)</code> 영역의 페이지 캐시를 생성한다.<li>성공하면 0 반환, 실패 시 -1반환하고 errno 설정</ul><h2 id="443-부담-없이-힌트를-사용하자-">4.4.3 부담 없이 힌트를 사용하자 !!</h2><ul><li>일반적으로 애플리케이션에서 발생하는 일부 부하는 커널에 힌트를 제공함으로써 쉽게 개선할 수 있음!<ul><li><em>힌트는 입출력의 부하를 완화시킨다.</em></ul><li>파일 조각을 읽기 전에 <code class="language-plaintext highlighter-rouge">POSIX_FADV_WILLNEED</code>(곧 접근) 힌트를 제공하여 커널이 읽으려는 파일을 페이지 캐시에 밀어 넣을 수 있음<ul><li>입출력은 백그라운드에서 비동기식으로 일어남. 애플리케이션이 최종적으로 파일에 접근하면 입출력을 블록킹하지 않고 원하는 작업을 완료할 수 있다.</ul><li>많은 데이터를 연속적으로 디스크에 기록하는 경우 <code class="language-plaintext highlighter-rouge">POSIX_FADV_DONTNEED</code>(당분간 접근 X) 힌트를 제공하면 파일 조각을 페이지 캐시에서 제거할 수도 있다.<ul><li>다시 접근하지 않으면, 불필요한 데이터로 가득 차있을 수 있기 때문에 주기적으로 캐시에서 스트림 데이터를 제거하는것이 합리적</ul><li>파일 전체를 읽을 때는 <code class="language-plaintext highlighter-rouge">POSIX_FADV_SEQUENTIAL</code>(순차적) 힌트를 사용해서 커널에 미리읽기를 공격적으로 수행하도록 할 수 있다.<li>파일을 랜덤하게 접근하거나 파일의 이곳 저곳을 읽어야 한다면 <code class="language-plaintext highlighter-rouge">POSIX_FADV_RANDOM</code>(랜덤하게 접근) 힌트를 사용해서 불필요한 미리읽기를 방지할 수 있음</ul><h1 id="45-동기화-동기식-비동기식-연산">4.5 동기화, 동기식, 비동기식 연산</h1><ul><li><code class="language-plaintext highlighter-rouge">동기식</code>(Synchronous)과 <code class="language-plaintext highlighter-rouge">동기화</code>(Synchroinized)는 크게 다르지 않음<li>동기식<ul><li><code class="language-plaintext highlighter-rouge">쓰기 연산</code><ul><li>동기식 쓰기 연산은 최소한 쓰고자 하는 데이터가 커널의 버퍼 캐시에 기록되기 전까지는 반환되지 않는다.<li>비동기식 쓰기 연산은 데이터가 사용자 영역에 머무르고 있을지라도 즉시 반환될 수 있다.</ul><li><code class="language-plaintext highlighter-rouge">읽기 연산</code><ul><li>동기식 읽기 연산은 읽고자 하는 데이터가 애플리케이션에서 제공하는 사용자 영역의 버퍼에 저장되기 전까지는 반환되지 않는다.<li>비동기식 읽기 연산은 읽으려는 데이터가 미처 준비되기도 전에 반환될 수 있다.</ul></ul><li>비동기식 연산은 나중을 위해 요청을 큐에 넣을 뿐 실제로 요청된 작업을 수행하지 않음!<li><code class="language-plaintext highlighter-rouge">동기화 연산</code>은 단순 동기식 연산보다 <strong>좀 더 제약적이지만 더 안전</strong>하다.<ul><li>동기화 쓰기 연산은 데이터를 디스크에 기록해서 커널 버퍼에 있던 데이터와 디스크에 기록된 데이터가 동기화되도록 보장한다.<li>동기화 읽기 연산은 항상 데이터의 최신 복사본을 반환하며 이 복사본은 디스크에서 읽어낼 가능성이 높다.</ul><li>→ 동기식과 비동기식이라는 용어는 입출력 연산이 반환하기 전에 데이터 저장과 같은 이벤트를 <code class="language-plaintext highlighter-rouge">기다리는지의 여부</code>를 나타냄<li><p>→ 동기화와 비동기화는 데이터를 디스크에 기록하는 것과 같은 <code class="language-plaintext highlighter-rouge">정확한 이벤트</code>가 발생해야 함을 나타냄</p><li>보통 유닉스의 쓰기 연산은 <code class="language-plaintext highlighter-rouge">동기식</code>이자 <code class="language-plaintext highlighter-rouge">비동기화</code> 연산임<ul><li>특징들의 모든 가능한 조합으로 동작이 가능함 | | 동기화 | 비동기화 | | ——– | ————————————————————————————— | ——————————————————————————————————– | | 동기식 | 데이터를 디스크에 다 비우기 전에는 반환되지 않음. O_SYNC 플래그 명시했을 때 이렇게 동작 | 데이터가 커널 버퍼에 저장되기 전까지 반환되지 않음. 일반적인 동작 | | 비동기식 | 요청이 큐에 들어가자마자 반환됨. 최종적으로 쓰기 연산이 실행되어야 디스크에 기록된다. | 요청이 큐에 들어가자마자 반환됨. 최종적으로 쓰기 연산이 실행되어야 적어도 데이터가 커널 버퍼에 저장된다. |</ul><li>읽기 연산은 <code class="language-plaintext highlighter-rouge">동기식</code>이면서 <code class="language-plaintext highlighter-rouge">동기화</code> 연산이다.<ul><li>오랜 데이터를 읽는 것이 의미가 없으므로 항상 동기화 방식으로 동작함 | | 동기화 | | ——– | ——————————————————————————————– | | 동기식 | 최신 데이터가 제공된 버퍼로 읽어오기 전에는 반환하지 않는다. 일반적 동작 | | 비동기식 | 요청이 큐에 들어가자마자 반환된다. 하지만 최종적으로 연산이 실행되어야 최신 데이터를 반환함. |</ul></ul><h2 id="451-비동기식-입출력">4.5.1 비동기식 입출력</h2><ul><li>비동기식 입출력을 수행하려면 커널의 최하위 레벨에서부터 지원이 필요하다.<li><code class="language-plaintext highlighter-rouge">aio</code> 인터페이스가 정의되어 있으며 리눅스에서 구현하고 있다.<li>이는 비동기식 입출력을 요청하고 작업이 완료되면 알림을 받는 함수를 제공함.</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;aio.h&gt;</span><span class="cp">
</span>
<span class="cm">/* asynchronous I/O control block */</span>
<span class="k">struct</span> <span class="n">aiocb</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">aio_fildes</span><span class="p">;</span>               <span class="cm">/* file descriptor */</span>
        <span class="kt">int</span> <span class="n">aio_lio_opcode</span><span class="p">;</span>           <span class="cm">/* operation to perform */</span>
        <span class="kt">int</span> <span class="n">aio_reqprio</span><span class="p">;</span>              <span class="cm">/* request priority offset */</span>
        <span class="k">volatile</span> <span class="kt">void</span> <span class="o">*</span><span class="n">aio_buf</span><span class="p">;</span>       <span class="cm">/* pointer to buffer */</span>
        <span class="kt">size_t</span> <span class="n">aio_nbytes</span><span class="p">;</span>            <span class="cm">/* length of operation */</span>
        <span class="k">struct</span> <span class="n">sigevent</span> <span class="n">aio_sigevent</span><span class="p">;</span> <span class="cm">/* signal number and value */</span>

        <span class="cm">/* internal, private members follow... */</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">aio_read</span> <span class="p">(</span><span class="k">struct</span> <span class="n">aiocb</span> <span class="o">*</span><span class="n">aiocbp</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">aio_write</span> <span class="p">(</span><span class="k">struct</span> <span class="n">aiocb</span> <span class="o">*</span><span class="n">aiocbp</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">aio_error</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">aiocb</span> <span class="o">*</span><span class="n">aiocbp</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">aio_return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">aiocb</span> <span class="o">*</span><span class="n">aiocbp</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">aio_cancel</span> <span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">aiocb</span> <span class="o">*</span><span class="n">aiocbp</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">aio_fsync</span> <span class="p">(</span><span class="kt">int</span> <span class="n">op</span><span class="p">,</span> <span class="k">struct</span> <span class="n">aiocb</span> <span class="o">*</span><span class="n">aiocbp</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">aio_suspend</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">aiocb</span> <span class="o">*</span> <span class="k">const</span> <span class="n">cblist</span><span class="p">[],</span>
                 <span class="kt">int</span> <span class="n">n</span><span class="p">,</span>
                 <span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">timeout</span><span class="p">);</span>
</pre></table></code></div></div><h1 id="46-입출력-스케줄러와-성능">4.6 입출력 스케줄러와 성능</h1><ul><li>디스크 성능을 가장 떨어뜨리는 부분은 <code class="language-plaintext highlighter-rouge">seek</code> 이라고 하는 하드 디스크에서 데이터를 읽고 쓰는 헤드를 이동시키는 과정이다.<ul><li>프로세스의 사이클 하나보다 <code class="language-plaintext highlighter-rouge">25,000,000배</code>나 더 오래 걸리는 시간.<li>입출력 요청을 순서대로 디스크로 보내는 방식은 비효율적임</ul><li>→ 입출력 스케줄러를 통해서 디스크 탐색 횟수를 최소화 함.</ul><h2 id="461-디스크-주소-지정-방식">4.6.1 디스크 주소 지정 방식</h2><ul><li>하드 디스크는 <code class="language-plaintext highlighter-rouge">실린더</code>, <code class="language-plaintext highlighter-rouge">헤드</code>, <code class="language-plaintext highlighter-rouge">섹터</code> 또는 <code class="language-plaintext highlighter-rouge">CHS 주소 지정방식</code>을 사용함<li>하드 디스크는 플래터 여러 장으로 구성되어 있으며, 각 플래터는 하나의 디스크, 스핀들, 그리고 read/write 헤더로 구성되어 있다.<li>플래터를 CD로 생각할 수 있다<li>각각의 플래터는 CD 처럼 원형의 트랙으로 나뉘어져 있다. 그 트랙들은 <code class="language-plaintext highlighter-rouge">정수 개의 섹터</code>로 나뉘어져 있음</ul><p><img data-proofer-ignore data-src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7cb84d35-c4c3-4df8-a3de-489d0d9aad60/Untitled.png" alt="Untitled" /></p><ul><li>특정 데이터가 저장되어 있는 디스크의 위치를 찾을 때 하드 디스크는 <code class="language-plaintext highlighter-rouge">실린더</code>, <code class="language-plaintext highlighter-rouge">헤드</code>, <code class="language-plaintext highlighter-rouge">섹터 값</code>을 필요로 함.<ul><li>어떤 플래터의 어느 트랙, 어느 섹터에 데이터가 있는지 알아야 함<li>실린더 값 : 데이터가 위치한 트랙을 나타냄<li>헤드 값 : 요청한 읽기/쓰기 헤드(정확한 플래터)의 정확한 값을 구분함<li>섹터 값 : 트랙에 위치한 정확한 섹터</ul><li>요즘 HD는 유일한 블록 번호를 맵핑해서 하나의 블록이 특정 섹터에 대응되도록 한다.<li><strong>반면 파일 시스템은 소프트웨어로만 존재함.</strong><ul><li><code class="language-plaintext highlighter-rouge">논리 블록</code>이라는 독자적인 단위를 사용해서 동작함.<li>파일 시스템의 논리 블록은 디스크의 하나 이상의 물리 블록에 맵핑되어 있다.</ul></ul><h2 id="462-입출력-스케줄러의-동작-방식">4.6.2 입출력 스케줄러의 동작 방식</h2><ul><li>입출력 스케줄러는 <code class="language-plaintext highlighter-rouge">병합</code>과 <code class="language-plaintext highlighter-rouge">정렬</code>이라는 두 가지 기본 동작을 수행한다.<ul><li><code class="language-plaintext highlighter-rouge">병합</code><ul><li>둘 이상의 인접한 입출력요청을 단일 요청으로 합치는 과정<li>예시 : 하나는 5번을 읽으려 하고, 하나는 6,7번까지 읽으려고 할 때 합쳐서 수행함. 연산 횟수는 절반으로 줄어듬</ul><li><code class="language-plaintext highlighter-rouge">정렬</code><ul><li>대기 중인 입출력 요청을 블록 순서의 오름차순으로 정렬하는 것이다.<li>예시 : 52, 109, 7에 대한 입출력 연산이 들어오면 입출력 스케줄러는 이 요청을 7, 52, 109 순서대로 정렬함.<ul><li>만약 81번 블록에 대한 새로운 요청이 들어오면 52번과 109번 연산 요청 사이에 끼워넣음</ul><li>선형적인 방법으로 부드럽게 이동시킬 수 있게 하여서 디스크의 헤드 움직임을 <code class="language-plaintext highlighter-rouge">최소화</code> 한다.</ul></ul></ul><h2 id="463-읽기-개선">4.6.3 읽기 개선</h2><ul><li><code class="language-plaintext highlighter-rouge">읽기 요청</code>은 반드시 최신 데이터를 반환해야 함<li>따라서 요청한 데이터가 페이지 캐시에 존재하지 않으면 디스크에서 데이터를 읽어올 때까지 블록되어야 하며 시간이 오래 걸릴 수 있음<li>→ <strong>읽기 Latency</strong> 라고 한다.<li>읽기의 경우 나중에 들어온 요청은 앞선 요청의 완료에 의존적이다.<li>이에 반해 <code class="language-plaintext highlighter-rouge">쓰기 요청</code>은 디스크 성능에 방해가 되지 않는 스트림을 사용하는데, 이는 커널과 디스크의 주의를 독차지 할 수 있다. → 이렇게 되면 읽기 문제가 복잡해지는데 이를 “<code class="language-plaintext highlighter-rouge">Writes-starving-reads problem</code>”이라고 한다<li><p>만약 입출력 스케줄러가 항상 요청이 들어온 순서에 따라 새로운 요청을 끼워 넣는다면 멀리 떨어진 블록에 대한 요청을 무기한으로 굶겨 죽일 수 있음.</p><li><code class="language-plaintext highlighter-rouge">리누스 엘리베이터</code> 같은 단순한 접근 방식은 큐에 충분히 오래된 요청이 있다면 삽입-정렬 기능을 멈춘다.<ul><li>전체 성능을 희생하여 요청에 대한 공정석을 유지하고 읽기 요청인 경우 레이턴시를 개선한다.<li>문제는 이 휴리스틱이 너무 단순하다는 것</ul></ul><h3 id="데드라인-입출력-스케줄러">데드라인 입출력 스케줄러</h3><ul><li>전통적인 엘리베이터 알고리즘의 일반적인 문제를 해결하기 위해 도입되었다.<li>리누스 엘리베이터는 대기 중인 입출력 요청을 정렬된 목록(<code class="language-plaintext highlighter-rouge">큐</code>)으로 유지한다.<li><code class="language-plaintext highlighter-rouge">데드라인 입출력 스케줄러</code>는 이 큐를 유지하고 <code class="language-plaintext highlighter-rouge">읽기 FIFO 큐</code>와 <code class="language-plaintext highlighter-rouge">쓰기 FIFO 큐</code>라는 두 가지 추가 큐를 도입해서 문제를 해결한다.<ul><li>각 큐에 들어있는 각 요청은 <code class="language-plaintext highlighter-rouge">만료기간</code>이 할당되어 있음.<li>읽기 500밀리초, 쓰기 5초</ul><li>새로운 입출력 요청이 들어오면 표준 큐에 삽입-정렬되고, 읽기 or 쓰기 FIFO 큐의 끝 부분에 위치한다.<ul><li>일반적으로 표준 큐가 블록 번호로 정렬되어 있으므로 탐색을 최소화하여 전체 처리량을 최대로 높임</ul><li><p>만약 읽기 쓰기 FIFO 큐 앞부분에 있는 아이템이 해당 표준 큐의 만료기간보다 오래되면 입출력 스케줄러는 포준 큐에서 입출력 요청을 처리하지 않고 해당 FIFO 큐에서 요청을 처리하기 시작함.</p><li>입출력 요청에 대해서 말랑한 데드라인을 강제한다.<li>비록 만료전에 처리된다고 보장할 수는 없지만, 이반적으로 거의 요청 만료시간 안에 처리함.<li><strong>읽기 요청의 만료시간이 좀 더 짧기 떄문에 쓰기가 읽기를 굶겨 죽이는 문제도 최소화 한다.</strong></ul><h3 id="예측-입출력-스케줄러">예측 입출력 스케줄러</h3><ul><li><code class="language-plaintext highlighter-rouge">데드라인 입출력 스케줄러</code>의 문제점<ol><li>연속된 읽기 요청이 계속 들어올 경우, 정렬된 큐의 요청을 처리하기 위해서 앞뒤로 계속 왔다 갔다함.<li>새로운 읽기 요청은 앞선 요청이 반환되어야만 처리되는데, 그렇게 되면 데이터를 읽어서 서비스 하는 데 한번, 다시 되돌리는데 한번해서 총 두번의 탐색을 낭비함.</ol><li>위의 문제점들을 해결하기 위해서 <code class="language-plaintext highlighter-rouge">예측 입출력 스케줄러</code>는 데드라인 입출력 스케줄러에다가 <code class="language-plaintext highlighter-rouge">예측 매커니즘</code>을 추가하였다.<li>예측 입출력 스케줄러는 읽기 요청이 들어오면 평소처럼 만료시간 내에 처리한다. 하지만 <strong>요청을 처리하고 아무것도 하지 않고 6밀리 초까지 기다림</strong>.<li>→ 6밀리 초는 애플리케이션이 파일 시스템의 동일한 부분에 대한 새로운 읽기를 요청할 충분한 시간이다.<ul><li>6밀리 초 까지 요청이 없다면 예측이 잘못되었음을 인정하고 이전 작업 내용을 반환한다.</ul><li>대부분의 읽기는 의존적이므로 에측을 통해 시간을 많이 아낄 수 있음</ul><h3 id="cfq-입출력-스케줄러">CFQ 입출력 스케줄러</h3><ul><li>Complete Fair Queuing<li>프로세스마다 <code class="language-plaintext highlighter-rouge">독자적인 큐</code>를 할당하고, 각 큐는 시간을 할당받는다.<li><code class="language-plaintext highlighter-rouge">Round Robin</code> 방식으로 각 큐를 순회하면서 큐의 허락된 시간이 다 지나거나, 요청이 남아 있지 않을 때 큐에 있는 요청을 처리함.<ul><li>시간이 남았지만, 더이상 요청이 큐에 없다면 CFQ 스케줄러는 짧은 시간 동안 (default = 10밀리초) 그 큐의 새로운 요청을 기다림.<ul><li>예측이 맞으면 탐색을 피하고, 틀리면 다음 프로세스의 큐로 간다.</ul></ul><li>프로세스의 개별 큐 안에서 동기화된 요청(읽기 요청…) 은 동기화되지 않은 요청보다 더 높은 우선순위를 가짐.<ul><li><em>→ 읽기 요청을 배려해서 쓰기 요청이 읽기를 굶겨 죽이는 문제를 회피한다.</em></ul><li><strong>대부분의 업무 부하에 적합하며 가장 먼저 고려해볼 만하다.</strong></ul><h3 id="noop-입출력-스케줄러">Noop 입출력 스케줄러</h3><ul><li>가장 기본적인 스케줄러<li><strong>정렬을 수행하지 않고 병합만 수행함.</strong><ul><li>→ 정렬할 필요가 없거나, 정렬을 하지 않는 장치에 특화된 스케줄러</ul></ul><h2 id="464-입출력-스케줄러-선택과-설정">4.6.4 입출력 스케줄러 선택과 설정</h2><ul><li>기본 입출력 스케줄러는 부팅 시 커널 명령행 인자인 <code class="language-plaintext highlighter-rouge">iosched</code> 를 통해서 선택할 수 있다.<li>유효한 값으로는 <code class="language-plaintext highlighter-rouge">cfq</code>, <code class="language-plaintext highlighter-rouge">deadline</code>, <code class="language-plaintext highlighter-rouge">noop</code> 이 있다.<li>실행 중에도 각 장치에 대해 <code class="language-plaintext highlighter-rouge">/sys/block/[device]/queue/scheduler</code> 값을 변경해서 선택할 수 있음<ul><li>device : 블록 디바이스를 의미</ul><li>입출력 스케줄러 설정 예시<div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="cp"># echo cfq &gt; /sys/block/hda/queue/scheduler
</span></pre></table></code></div></div></ul><h2 id="465-입출력-성능-최적화">4.6.5 입출력 성능 최적화</h2><ul><li><strong>디스크 입출력은 많이 느리기 떄문에 성능 극대화는 매우 중요함</strong><li>여러가지 기법들<ol><li>자잘한 연산을 묶어 몇 개로 합쳐서 연산 최소화 하기<li>입출력을 블록 크기에 정렬되도록 수행하기<li>사용자 버퍼링을 사용하기<li>벡터 입출력<li>위치를 지정한 입출력<li>비동기식 입출력</ol></ul><h3 id="사용자-영역에서-입출력-스케줄링하기">사용자 영역에서 입출력 스케줄링하기</h3><ul><li>엄청난 입출력을 처리해야 하는 애플리케이션은 입출력 요청을 정렬하고 병합해서 조금이라도 더 성능을 높여야함.<ul><li>(<em>입출력이 많지 않은 애플리케이션에서 정렬하는 것은 어리석은 짓</em>)</ul><li>만약 입출력 요청이 계속 들어오고 있는 상황에서 중간에 정렬을 하는 것은 비효율적이다. 따라서 요청을 제출하기 전에 정렬을 해주면 원하는 순서대로 수행이 가능함.</ul><h3 id="경로로-정렬하기">경로로 정렬하기</h3><ul><li><code class="language-plaintext highlighter-rouge">파일 경로</code>로 정렬하는 방법은 가장 쉽지만, 효과는 적은 방법이다. (블록 단위 정렬을 흉내내는 방식)<li>대부분의 파일시스템의 배치 알고리즘에 의해 디렉터리 내의 파일 혹은 부모 디렉터리를 공유하는 디렉터리들은 디스크에서 인접하는 경향이 있음.<li>→ 파일의 물리적인 위치를 얼추 비슷하게 맞출 수 있다.<li>장점<ul><li>적어도 모든 파일 시스템에 적용 가능한 방법<li>일시적인 지역성 덕분에 중간 정도의 정확도를 기대할 수 있음.<li>구현하기 쉬움</ul><li>단점<ul><li><code class="language-plaintext highlighter-rouge">파편화</code>를 고려하지 않았음</ul></ul><h3 id="inode로-정렬하기">inode로 정렬하기</h3><ul><li><code class="language-plaintext highlighter-rouge">inode</code> 는 개별 파일과 관련된 메타데이터를 담고 있는 유닉스의 구성 요소이다.<li>파일의 데이터가 물리 디스크 블록을 여러개 점유하고 있다고 해도, 하나의 inode만을 가짐.<li>inode 는 유일한 번호가 할당됨.</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="err">파일</span> <span class="n">i</span><span class="err">의</span> <span class="n">inode</span> <span class="err">번호</span> <span class="o">&lt;</span> <span class="err">파일</span> <span class="n">j</span><span class="err">의</span> <span class="n">inode</span> <span class="err">번호</span>

<span class="o">==</span>

<span class="err">파일</span> <span class="n">i</span><span class="err">의</span> <span class="err">물리블록</span> <span class="o">&lt;</span> <span class="err">파일</span> <span class="n">j</span><span class="err">의</span> <span class="err">물리블록</span>
</pre></table></code></div></div><ul><li>inode의 번호는 <code class="language-plaintext highlighter-rouge">stat()</code> 시스템 콜을 통해서 얻을 수 있음<li><p>주어진 파일의 inode 번호 출력 프로그램 예시</p><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/stat.h&gt;</span><span class="cp">
</span>
<span class="cm">/*
 * get_inode - returns the inode of the file associated
 * with the given file descriptor, or −1 on failure
 */</span>
<span class="kt">int</span> <span class="nf">get_inode</span> <span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">stat</span> <span class="n">buf</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="n">fstat</span> <span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">perror</span> <span class="p">(</span><span class="s">"fstat"</span><span class="p">);</span>
                <span class="k">return</span> <span class="err">−</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">buf</span><span class="p">.</span><span class="n">st_ino</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">inode</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">fprintf</span> <span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"usage: %s &lt;file&gt;</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
                <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span> <span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">O_RDONLY</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">perror</span> <span class="p">(</span><span class="s">"open"</span><span class="p">);</span>
                <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">inode</span> <span class="o">=</span> <span class="n">get_inode</span> <span class="p">(</span><span class="n">fd</span><span class="p">);</span>
        <span class="n">printf</span> <span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><li>inode 정렬 장점<ul><li>inode번호는 쉽게 얻을 수 있고 정렬도 쉬움<li>물리적인 파일 배치를 추측할 수 있는 좋은 지표</ul><li>단점<ul><li>파편화에 따라 추측이 틀릴 수 있음<li>유닉스 파일 시스템이 아닌 경우 정확도가 떨어짐</ul><li>사용자 영역에서 입출력 요청을 스케줄링하기 위해서 가장 흔히 사용되는 방법</ul><h3 id="물리-블록으로-정렬하기">물리 블록으로 정렬하기</h3><ul><li>최적의 방법은 물리적인 디스크 블록으로 정렬하는 것임<li>각 파일은 파일 시스템에서 가장 작은 할당 단위인 <code class="language-plaintext highlighter-rouge">논리 블록 단위</code>로 쪼개짐.<ul><li>(<em>논리 블록 크기는 파일 시스템 마다 다르다.</em>)</ul><li>각각의 <strong>논리 블록은 하나의 물리 블록에 맵핑</strong>되어 있다.<li><p>커널은 파일의 논리 블록에서 물리 디스크 블록을 알아내는 메서드를 제공한다.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">ret</span> <span class="o">=</span> <span class="n">ioctl</span> <span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">FIBMAP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">perror</span> <span class="p">(</span><span class="s">"ioctl"</span><span class="p">);</span>
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">block</code><ul><li>찾고 싶은 물리 블록에 대한 논리 블록<li>block은 0부터 시작하는 파일에 상대적인 값.</ul><li>성공하면 block 은 물리 블록 번호로 바뀐다.</ul><li>논리 블록과 물리 블록의 맵핑을 찾으려면 2단계가 필요함.</ul><ol><li>주어진 파일의 블록 개수를 구함<ul><li><code class="language-plaintext highlighter-rouge">stat()</code> 시스템 콜로 구할 수 있다.</ul><li>각 논리 블록을 가지고 ioctl()을 통해 이에 상응하는 물리 블록을 구한다.</ol><ul><li><p>예제</p><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/stat.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/ioctl.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/fs.h&gt;</span><span class="cp">
</span>
<span class="cm">/*
 * get_block - for the file associated with the given fd, returns
 * the physical block mapping to logical_block
 */</span>
<span class="kt">int</span> <span class="nf">get_block</span> <span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">logical_block</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="n">ioctl</span> <span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">FIBMAP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">logical_block</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">perror</span> <span class="p">(</span><span class="s">"ioctl"</span><span class="p">);</span>
                <span class="k">return</span> <span class="err">−</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">logical_block</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*
 * get_nr_blocks - returns the number of logical blocks
 * consumed by the file associated with fd
 */</span>
<span class="kt">int</span> <span class="nf">get_nr_blocks</span> <span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">stat</span> <span class="n">buf</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="n">fstat</span> <span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">perror</span> <span class="p">(</span><span class="s">"fstat"</span><span class="p">);</span>
                <span class="k">return</span> <span class="err">−</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">buf</span><span class="p">.</span><span class="n">st_blocks</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*
 * print_blocks - for each logical block consumed by the file
 * associated with fd, prints to standard out the tuple
 * "(logical block, physical block)"
 */</span>
<span class="kt">void</span> <span class="nf">print_blocks</span> <span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">nr_blocks</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

        <span class="n">nr_blocks</span> <span class="o">=</span> <span class="n">get_nr_blocks</span> <span class="p">(</span><span class="n">fd</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nr_blocks</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">fprintf</span> <span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"get_nr_blocks failed!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
                <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">nr_blocks</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">printf</span> <span class="p">(</span><span class="s">"no allocated blocks</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
                <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nr_blocks</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">printf</span> <span class="p">(</span><span class="s">"1 block</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">else</span>
                <span class="n">printf</span> <span class="p">(</span><span class="s">"%d blocks</span><span class="se">\n\n</span><span class="s">"</span><span class="p">,</span> <span class="n">nr_blocks</span><span class="p">);</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_blocks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">int</span> <span class="n">phys_block</span><span class="p">;</span>

                <span class="n">phys_block</span> <span class="o">=</span> <span class="n">get_block</span> <span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">phys_block</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">fprintf</span> <span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"get_block failed!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
                        <span class="k">return</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phys_block</span><span class="p">)</span>
                        <span class="k">continue</span><span class="p">;</span>

                <span class="n">printf</span> <span class="p">(</span><span class="s">"(%u, %u) "</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">phys_block</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">putchar</span> <span class="p">(</span><span class="sc">'\N'</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">fprintf</span> <span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"usage: %s &lt;file&gt;</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
                <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span> <span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">O_RDONLY</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">perror</span> <span class="p">(</span><span class="s">"open"</span><span class="p">);</span>
                <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">print_blocks</span> <span class="p">(</span><span class="n">fd</span><span class="p">);</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><li>장점<ul><li>정확히 정렬하고 싶은 대상인 파일이 실제 존재하는 물리 디스크 블록을 반환한다</ul><li>단점<ul><li>root 권한이 필요함.<li>ioctl의 <code class="language-plaintext highlighter-rouge">FIBMAP</code>이 root 권한이 필요한 <code class="language-plaintext highlighter-rouge">CAP_SYS_RAWIO</code> 기능을 요구함</ul></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/linux/'>Linux</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/blog/" class="post-tag no-text-decoration" >blog</a> <a href="/tags/jekyll/" class="post-tag no-text-decoration" >jekyll</a> <a href="/tags/jekyll-theme/" class="post-tag no-text-decoration" >jekyll theme</a> <a href="/tags/next-theme/" class="post-tag no-text-decoration" >NexT theme</a> <a href="/tags/computer-science/" class="post-tag no-text-decoration" >Computer Science</a> <a href="/tags/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B3%B5%ED%95%99/" class="post-tag no-text-decoration" >컴퓨터공학</a> <a href="/tags/%EA%B0%9C%EB%B0%9C/" class="post-tag no-text-decoration" >개발</a> <a href="/tags/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4/" class="post-tag no-text-decoration" >소프트웨어</a> <a href="/tags/%EC%A7%80%ED%82%AC-%ED%85%8C%EB%A7%88/" class="post-tag no-text-decoration" >지킬 테마</a> <a href="/tags/%EC%A7%80%ED%82%AC-%EB%B8%94%EB%A1%9C%EA%B7%B8-%ED%8F%AC%EC%8A%A4%ED%8C%85/" class="post-tag no-text-decoration" >지킬 블로그 포스팅</a> <a href="/tags/github-pages/" class="post-tag no-text-decoration" >GitHub Pages</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=[Linux System Programming] Ch04 고급 버퍼 입출력 - Hans H. Kim&url=https://hhhyunwoo.github.io//posts/linux_ch04/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=[Linux System Programming] Ch04 고급 버퍼 입출력 - Hans H. Kim&u=https://hhhyunwoo.github.io//posts/linux_ch04/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=[Linux System Programming] Ch04 고급 버퍼 입출력 - Hans H. Kim&url=https://hhhyunwoo.github.io//posts/linux_ch04/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/blog-newjourney/">🏢 첫번째 퇴사, 첫번째 이직</a><li><a href="/posts/k8s-nginx-413-error/">[K8S] Ingress Nginx 413 http error (payload too large) 이슈 해결</a><li><a href="/posts/infiniband-nccl-issue/">[Infiniband] NCCL WARN Call to ibv_reg_mr failed 이슈 해결</a><li><a href="/posts/k8s_service/">[Kubernetes] Kubernetes 서비스 정리(ClusterIP, Nodeport, Loadbalancer) </a><li><a href="/posts/k8s-kernel-epoll-etcd-leader/">[K8S] 5.4.0-132 커널의 epoll 버그로 인한 etcd leader election 이슈</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/blog/">blog</a> <a class="post-tag" href="/tags/github-pages/">GitHub Pages</a> <a class="post-tag" href="/tags/jekyll-theme/">jekyll theme</a> <a class="post-tag" href="/tags/jekyll/">jekyll</a> <a class="post-tag" href="/tags/next-theme/">NexT theme</a> <a class="post-tag" href="/tags/%EC%A7%80%ED%82%AC-%EB%B8%94%EB%A1%9C%EA%B7%B8-%ED%8F%AC%EC%8A%A4%ED%8C%85/">지킬 블로그 포스팅</a> <a class="post-tag" href="/tags/%EC%A7%80%ED%82%AC-%ED%85%8C%EB%A7%88/">지킬 테마</a> <a class="post-tag" href="/tags/computer-science/">Computer Science</a> <a class="post-tag" href="/tags/%EA%B0%9C%EB%B0%9C/">개발</a> <a class="post-tag" href="/tags/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4/">소프트웨어</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/docker/"><div class="card-body"> <span class="timeago small" >Feb 7, 2022<i class="unloaded">2022-02-07T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Docker] Centos Image 에서 sudo command not found 에러</h3><div class="text-muted small"><p> Centos Image 에서 sudo command not found centos/python-36-centos7 이미지 사용 도중 Dockerfile 내부에서 커맨드로 파일의 모드를 바꿔야할 일이 생겼다. RUN sudo chmod 755 start.sh 근데 sudo 를 실행했을 떄 /bin/sh: sudo: command not fo...</p></div></div></a></div><div class="card"> <a href="/posts/First-post/"><div class="card-body"> <span class="timeago small" >Nov 12, 2021<i class="unloaded">2021-11-12T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>First Post</h3><div class="text-muted small"><p> Welcome Hello world, this is my first Jekyll blog post. I hope you like it!</p></div></div></a></div><div class="card"> <a href="/posts/tb07-jekyll-bundler-error/"><div class="card-body"> <span class="timeago small" >Nov 13, 2021<i class="unloaded">2021-11-13T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Trouble Shooting] Jekyll chirpy 템플릿으로 Github 블로그 시작하기. (Bundler Install Error)</h3><div class="text-muted small"><p> Jekyll chirpy 템플릿으로 Github 블로그 시작하기. (Bundler Install Error) Github 블로그 with Chirpy Jekyll Theme github 블로그를 시작할 때 Jekyll을 많이 사용한다. 그럼 Jekyll이 무엇일까? Jekyll? 텍스트 변환 엔진으로, Markup 언어로 글을 작성하면 이...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/linux_ch03/" class="btn btn-outline-primary" prompt="Older"><p>[Linux System Programming] Ch03 버퍼 입출력</p></a> <a href="/posts/linux_ch05/" class="btn btn-outline-primary" prompt="Newer"><p>[Linux System Programming] Ch05 프로세스 관리</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://github.com/hhhyunwoo">Hans H. Kim</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/blog/">blog</a> <a class="post-tag" href="/tags/github-pages/">GitHub Pages</a> <a class="post-tag" href="/tags/jekyll-theme/">jekyll theme</a> <a class="post-tag" href="/tags/jekyll/">jekyll</a> <a class="post-tag" href="/tags/next-theme/">NexT theme</a> <a class="post-tag" href="/tags/%EC%A7%80%ED%82%AC-%EB%B8%94%EB%A1%9C%EA%B7%B8-%ED%8F%AC%EC%8A%A4%ED%8C%85/">지킬 블로그 포스팅</a> <a class="post-tag" href="/tags/%EC%A7%80%ED%82%AC-%ED%85%8C%EB%A7%88/">지킬 테마</a> <a class="post-tag" href="/tags/computer-science/">Computer Science</a> <a class="post-tag" href="/tags/%EA%B0%9C%EB%B0%9C/">개발</a> <a class="post-tag" href="/tags/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4/">소프트웨어</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-EPY53PE167"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-EPY53PE167'); }); </script>
